// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 12.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Spike.Build.AS3
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "12.0.0.0")]
    public partial class AS3Template : AS3TemplateBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("\r\n");
            
            #line 8 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "LZF") { 
            
            #line default
            #line hidden
            this.Write("package spike\r\n{\r\n\t/*\r\n\t* ActionScript3 LibLZF Port:\r\n\t* Copyright (c) 2010 Roman" +
                    " Atachiants <roman@misakai.com>\r\n\t* \r\n\t* Original CLZF C# Port:\r\n\t* Copyright (c" +
                    ") 2005 Oren J. Maurice <oymaurice@hazorea.org.il>\r\n\t* \r\n\t* Original LibLZF Libra" +
                    "ry & Algorithm:\r\n\t* Copyright (c) 2000-2008 Marc Alexander Lehmann <schmorp@schm" +
                    "orp.de>\r\n\t* \r\n\t* Redistribution and use in source and binary forms, with or with" +
                    "out modifica-\r\n\t* tion, are permitted provided that the following conditions are" +
                    " met:\r\n\t* \r\n\t*   1.  Redistributions of source code must retain the above copyri" +
                    "ght notice,\r\n\t*       this list of conditions and the following disclaimer.\r\n\t* " +
                    "\r\n\t*   2.  Redistributions in binary form must reproduce the above copyright\r\n\t*" +
                    "       notice, this list of conditions and the following disclaimer in the\r\n\t*  " +
                    "     documentation and/or other materials provided with the distribution.\r\n\t* \r\n" +
                    "\t*   3.  The name of the author may not be used to endorse or promote products\r\n" +
                    "\t*       derived from this software without specific prior written permission.\r\n" +
                    "\t* \r\n\t* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS\'\' AND ANY EXPRESS OR IMP" +
                    "LIED\r\n\t* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF ME" +
                    "R-\r\n\t* CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\r" +
                    "\n\t* EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\r" +
                    "\n\t* CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n\t" +
                    "* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\r\n\t" +
                    "* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n\t* W" +
                    "HETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\r\n\t* " +
                    "ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n\t* " +
                    "OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\t*\r\n\t* Alternatively, the contents of this f" +
                    "ile may be used under the terms of\r\n\t* the GNU General Public License version 2 " +
                    "(the \"GPL\"), in which case the\r\n\t* provisions of the GPL are applicable instead " +
                    "of the above. If you wish to\r\n\t* allow the use of your version of this file only" +
                    " under the terms of the\r\n\t* GPL and not to allow others to use your version of t" +
                    "his file under the\r\n\t* BSD license, indicate your decision by deleting the provi" +
                    "sions above and\r\n\t* replace them with the notice and other provisions required b" +
                    "y the GPL. If\r\n\t* you do not delete the provisions above, a recipient may use yo" +
                    "ur version\r\n\t* of this file under either the BSD or the GPL.\r\n\t*/\r\n\timport flash" +
                    ".utils.ByteArray;\r\n\t\r\n\t/**\r\n\t* ActionScript3 LZF Compressor, a very small data c" +
                    "ompression library. The compression algorithm is extremely fast.\r\n\t*/\r\n\tpublic c" +
                    "lass LZF\r\n\t{\r\n\t\tstatic public var instance:LZF = new LZF();\r\n\t\t\r\n\t\tprivate const" +
                    " HLOG:Number = 14;\r\n\t\tprivate const HSIZE:Number = (1 << 14);\r\n\t\tprivate const M" +
                    "AX_LIT:Number = (1 << 5);\r\n\t\tprivate const MAX_OFF:Number = (1 << 13);\r\n\t\tprivat" +
                    "e const MAX_REF:Number = ((1 << 8) + (1 << 3));\r\n\t\tprivate var HashTable:Array =" +
                    " new Array(HSIZE);\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t\t* Compresses the data using LibLZF algorithm" +
                    "\r\n\t\t\t*/\r\n\t\tpublic function compress(input:ByteArray, inputLength:Number):ByteArr" +
                    "ay\r\n\t\t{\r\n\t\t\tHashTable.splice(0, HSIZE);\r\n\t\t\t\r\n\t\t\tvar output:ByteArray = new Byte" +
                    "Array();\r\n\t\t\t\r\n\t\t\tvar hslot:Number;\r\n\t\t\tvar iidx:Number = 0;\r\n\t\t\tvar oidx:Number" +
                    " = 0;\r\n\t\t\tvar reference:Number;\r\n\t\t\t\r\n\t\t\tvar hval:Number = (((input[iidx]) << 8)" +
                    " | input[iidx + 1]); // FRST(in_data, iidx);\r\n\t\t\tvar off:Number;\r\n\t\t\tvar lit:Num" +
                    "ber = 0;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tfor (; ; )\r\n\t\t\t{\r\n\t\t\t\tif (iidx < inputLength - 2)\r\n\t\t\t\t{\r" +
                    "\n\t\t\t\t\thval = (hval << 8) | input[iidx + 2];\r\n\t\t\t\t\thslot = ((hval ^ (hval << 5)) " +
                    ">> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));\r\n\t\t\t\t\treference = HashTabl" +
                    "e[hslot];\r\n\t\t\t\t\tHashTable[hslot] = iidx;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tif ((off = iidx - r" +
                    "eference - 1) < MAX_OFF\r\n\t\t\t\t\t\t&& iidx + 4 < inputLength\r\n\t\t\t\t\t\t&& reference > 0" +
                    "\r\n\t\t\t\t\t\t&& input[reference + 0] == input[iidx + 0]\r\n\t\t\t\t\t\t&& input[reference + 1" +
                    "] == input[iidx + 1]\r\n\t\t\t\t\t\t&& input[reference + 2] == input[iidx + 2]\r\n\t\t\t\t\t)\r\n" +
                    "\t\t\t\t\t{\r\n\t\t\t\t\t\t/* match found at *reference++ */\r\n\t\t\t\t\t\tvar len:Number = 2;\r\n\t\t\t\t" +
                    "\t\tvar maxlen:Number = inputLength - iidx - len;\r\n\t\t\t\t\t\tmaxlen = maxlen > MAX_REF" +
                    " ? MAX_REF : maxlen;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t\tlen++;\r\n\t\t\t\t\t\twhile (len < maxlen" +
                    " && input[reference + len] == input[iidx + len]);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (lit != 0)\r\n" +
                    "\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\t\toutput.writeByte(lit - 1);\r\n\t\t\t\t\t\t\tlit = -lit;\r\n" +
                    "\t\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\t\t\toutput.writeByte(input[iidx + lit]" +
                    ");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\twhile ((++lit) != 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlen -= 2;\r\n\t\t" +
                    "\t\t\t\tiidx++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (len < 7)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\t\toutput." +
                    "writeByte((off >> 8) + (len << 5));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\toidx++" +
                    ";\r\n\t\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\t\toutput.writeByte((off >> 8) + (7 << 5));\r\n\t\t\t\t\t\t\toutpu" +
                    "t.writeByte(len - 7);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\toutput.writeByte(of" +
                    "f);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tiidx += len - 1;\r\n\t\t\t\t\t\thval = (uint)(((input[iidx]) << 8) | " +
                    "input[iidx + 1]); \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\thval = (hval << 8) | input[iidx + 2];\r\n\t\t\t\t\t\tH" +
                    "ashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - " +
                    "1))] = iidx;\r\n\t\t\t\t\t\tiidx++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\thval = (hval << 8) | input[iidx + 2];" +
                    "\r\n\t\t\t\t\t\tHashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & " +
                    "(HSIZE - 1))] = iidx;\r\n\t\t\t\t\t\tiidx++;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse i" +
                    "f (iidx == inputLength)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\t\t/* one more literal byte we must" +
                    " copy */\r\n\t\t\t\tlit++;\r\n\t\t\t\tiidx++;\r\n\t\t\t\t\r\n\t\t\t\tif (lit == MAX_LIT)\r\n\t\t\t\t{\r\n\t\t\t\t\toi" +
                    "dx++;\r\n\t\t\t\t\toutput.writeByte((MAX_LIT - 1));\r\n\t\t\t\t\tlit = -lit;\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t{\r" +
                    "\n\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\toutput.writeByte(input[iidx + lit]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile (" +
                    "(++lit) != 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (lit != 0)\r\n\t\t\t{\r\n\t\t\t\toidx++;\r\n\t\t\t\toutpu" +
                    "t.writeByte((lit - 1));\r\n\t\t\t\tlit = -lit;\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\toidx++;\r\n\t\t\t\t\toutp" +
                    "ut.writeByte(input[iidx + lit]);\r\n\t\t\t\t}\r\n\t\t\t\twhile ((++lit) != 0);\r\n\t\t\t}\r\n\t\t\t\r\n\t" +
                    "\t\toutput.length = oidx;\r\n\t\t\treturn output;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t\t* Decompresse" +
                    "s the data using LibLZF algorithm\r\n\t\t\t*/\r\n\t\tpublic function decompress(input:Byt" +
                    "eArray, inputLength:Number):ByteArray\r\n\t\t{\r\n\t\t\tvar iidx:Number = 0;\r\n\t\t\tvar oidx" +
                    ":Number = 0;\r\n\t\t\tvar output:ByteArray = new ByteArray();\r\n\t\t\t\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\t" +
                    "var ctrl:Number = input[iidx++];\r\n\t\t\t\t\r\n\t\t\t\tif (ctrl < (1 << 5)) /* literal run " +
                    "*/\r\n\t\t\t\t{\r\n\t\t\t\t\tctrl++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\toutput.wri" +
                    "teByte(input[iidx++]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile ((--ctrl) != 0);\r\n\t\t\t\t}\r\n\t\t\t\telse /* " +
                    "back reference */\r\n\t\t\t\t{\r\n\t\t\t\t\tvar len:Number = ctrl >> 5;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar refe" +
                    "rence:int = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (len == 7)\r\n" +
                    "\t\t\t\t\t\tlen += input[iidx++];\r\n\t\t\t\t\t\r\n\t\t\t\t\treference -= input[iidx++];\r\n\t\t\t\t\t\r\n\t\t\t" +
                    "\t\tif (reference < 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//SET_ERRNO (EINVAL);\r\n\t\t\t\t\t\toutput.length =" +
                    " 0;\r\n\t\t\t\t\t\treturn output;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\toutput.writeByte(output[reference" +
                    "++]);\r\n\t\t\t\t\toidx++;\r\n\t\t\t\t\toutput.writeByte(output[reference++]);\r\n\t\t\t\t\toidx++;\r\n" +
                    "\t\t\t\t\t\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toutput.writeByte(output[reference++]);\r\n\t\t\t\t\t\toidx" +
                    "++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile ((--len) != 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (iidx < inputLeng" +
                    "th);\r\n\t\t\t\r\n\t\t\toutput.length = oidx;\r\n\t\t\treturn output;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n\r\n}");
            
            #line 8 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 9 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "PacketWriter") { 
            
            #line default
            #line hidden
            this.Write(" ");
            this.Write("package spike\r\n{\r\n\timport flash.utils.ByteArray;\r\n\t\r\n\tpublic class PacketWriter\r\n" +
                    "\t{\r\n\t\t// internal buffer\r\n\t\tpublic var buffer:ByteArray = new ByteArray();\r\n\t\t\r\n" +
                    "\t\tpublic function PacketWriter()\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Compresse le packe" +
                    "t\r\n\t\t */\r\n\t\tpublic function compress():void\r\n\t\t{\t\t\t\r\n\t\t\tbuffer = LZF.instance.co" +
                    "mpress(buffer, buffer.length);\r\n\t\t}\t\r\n\r\n\t\t/*\r\n\t\t * Ecrit un octet (l\'ID du packe" +
                    "t) dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteOperation(value:int):" +
                    "void\r\n\t\t{\r\n\t\t\tbuffer.writeShort(value);\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Ecrit un entier 16b" +
                    "it dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteInt16(value:Number):v" +
                    "oid\r\n\t\t{\r\n\t\t\tbuffer.writeShort(value);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un entier 16bit " +
                    "dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteUInt16(value:Number):voi" +
                    "d\r\n\t\t{\r\n\t\t\tbuffer.writeShort(value);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t/*\r\n\t\t * Ecrit un entier da" +
                    "ns le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteInt32(value:int):void\r\n\t\t{" +
                    "\r\n\t\t\tbuffer.writeInt(value);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un octet dans le packet à " +
                    "envoyer\r\n\t\t */\r\n\t\tpublic function WriteByte(value:uint):void\r\n\t\t{\r\n\t\t\tbuffer.wri" +
                    "teByte(value);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un octet dans le packet à envoyer\r\n\t\t */" +
                    "\r\n\t\tpublic function WriteSByte(value:int):void\r\n\t\t{\r\n\t\t\tbuffer.writeByte(value);" +
                    "\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Ecrit un entier dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic " +
                    "function WriteNumber(value:Number):void\r\n\t\t{\r\n\t\t\tbuffer.writeInt(value);\r\n\t\t}\r\n\r" +
                    "\n\t\t/*\r\n\t\t * Ecrit un double dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function W" +
                    "riteDouble(value:Number):void\r\n\t\t{\r\n\t\t\tbuffer.writeDouble(value);\r\n\t\t}\r\n\r\n\t\t/*\r\n" +
                    "\t\t * Ecrit un double dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteSin" +
                    "gle(value:Number):void\r\n\t\t{\r\n\t\t\tbuffer.writeFloat(value);\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * E" +
                    "crit une valeur booleene dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function Writ" +
                    "eBoolean(value:Boolean):void\r\n\t\t{\r\n\t\t\tbuffer.writeBoolean(value);\r\n\t\t}\r\n\t\t\r\n\t\t/*" +
                    "\r\n\t\t * Ecrit une entier non-signé dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic func" +
                    "tion WriteUInt32(value:uint):void\r\n\t\t{\r\n\t\t\tbuffer.writeUnsignedInt(value);\r\n\t\t}\r" +
                    "\n\r\n\t\t/**\r\n\t\t * Writes a 64-bit signed integer to the buffer\r\n\t\t */\r\n\t\tpublic fun" +
                    "ction WriteInt64(value:Int64):void\r\n\t\t{\r\n\t\t\tWriteUInt32(value.low);\r\n\t\t\tWriteInt" +
                    "32(value.high);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Writes a 64-bit unsigned integer to the buff" +
                    "er\r\n\t\t */\r\n\t\tpublic function WriteUInt64(value:UInt64):void\r\n\t\t{\r\n\t\t\tWriteUInt32" +
                    "(value.low);\r\n\t\t\tWriteUInt32(value.high);\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Writes a dynamic" +
                    " member to the buffer\r\n\t\t */\r\n\t\tpublic function WriteDynamic(value:Object):void\r" +
                    "\n\t\t{\r\n\t\t\tif(value is Int64)\r\n\t\t\t{\r\n\t\t\t\tWriteByte(1);\r\n\t\t\t\tWriteString(\"Int64\");\r" +
                    "\n\t\t\t\tWriteInt64(value as Int64);\r\n\t\t\t} \r\n\t\t\telse if(value is UInt64)\r\n\t\t\t{\r\n\t\t\t\t" +
                    "WriteByte(1);\r\n\t\t\t\tWriteString(\"UInt64\");\r\n\t\t\t\tWriteUInt64(value as UInt64);\r\n\t\t" +
                    "\t}\r\n\t\t\telse if(value is int)\r\n\t\t\t{\r\n\t\t\t\tWriteByte(1);\r\n\t\t\t\tWriteString(\"Int32\");" +
                    "\r\n\t\t\t\tWriteInt32(value as int);\r\n\t\t\t}\r\n\t\t\telse if(value is uint)\r\n\t\t\t{\r\n\t\t\t\tWrit" +
                    "eByte(1);\r\n\t\t\t\tWriteString(\"UInt32\");\r\n\t\t\t\tWriteUInt32(value as uint);\r\n\t\t\t}\r\n\t\t" +
                    "\telse if(value is Number)\r\n\t\t\t{\r\n\t\t\t\tWriteByte(1);\r\n\t\t\t\tWriteString(\"Double\");\r\n" +
                    "\t\t\t\tWriteDouble(value as Number);\r\n\t\t\t}\r\n\t\t\telse if(value is Boolean)\r\n\t\t\t{\r\n\t\t\t" +
                    "\tWriteByte(1);\r\n\t\t\t\tWriteString(\"Boolean\");\r\n\t\t\t\tWriteBoolean(value as Boolean);" +
                    "\r\n\t\t\t}\r\n\t\t\telse if(value is Date)\r\n\t\t\t{\r\n\t\t\t\tWriteByte(1);\r\n\t\t\t\tWriteString(\"Dat" +
                    "eTime\");\r\n\t\t\t\tWriteDateTime(value as Date);\r\n\t\t\t}\r\n\t\t\telse if(value is String)\r\n" +
                    "\t\t\t{\r\n\t\t\t\tWriteByte(1);\r\n\t\t\t\tWriteString(\"String\");\r\n\t\t\t\tWriteString(value as St" +
                    "ring);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tWriteByte(0);\r\n\t\t\t\t//throw new Error(\"WriteDyna" +
                    "mic is not yet implemented\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\t\t\r\n\r\n\t\t/*\r\n\t\t * Ecrit une date dan" +
                    "s le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteDateTime(value:Date):void\r\n" +
                    "\t\t{\r\n\t\t\tbuffer.writeShort(value.fullYearUTC);\r\n\t\t\tbuffer.writeShort(value.monthU" +
                    "TC);\r\n\t\t\tbuffer.writeShort(value.dateUTC);\r\n\t\t\tbuffer.writeShort(value.hoursUTC)" +
                    ";\r\n\t\t\tbuffer.writeShort(value.minutesUTC);\r\n\t\t\tbuffer.writeShort(value.secondsUT" +
                    "C);\r\n\t\t\tbuffer.writeShort(value.millisecondsUTC);\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Ecrit une" +
                    " chaîne UTF8 dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteString(valu" +
                    "e:String):void\r\n\t\t{\r\n\t\t\tif(value == null || value == \"\")\r\n\t\t\t{\r\n\t\t\t\tWriteInt32(0" +
                    ");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar stringBuffer:ByteArray = new ByteArray();\r\n\t\t\t\t" +
                    "stringBuffer.writeUTFBytes(value);\r\n\t\t\t\tWriteInt32(stringBuffer.length);\r\n\t\t\t\tbu" +
                    "ffer.writeBytes(stringBuffer,0, stringBuffer.length);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t/*\r\n\t\t *" +
                    " Ecrit un IPacket dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WritePacket" +
                    "(value:IPacket):void\r\n\t\t{\r\n\t\t\tvalue.write(this);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un byt" +
                    "e array dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteByteArray(value:" +
                    "ByteArray):void\r\n\t\t{\r\n\t\t\tbuffer.writeInt(value.length);\r\n\t\t\tbuffer.writeBytes(va" +
                    "lue,0, value.length);\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Ecrit un IEntity dans le packet à env" +
                    "oyer\r\n\t\t */\r\n\t\tpublic function WriteEntity(value:IEntity):void\r\n\t\t{\r\n\t\t\tvalue.wr" +
                    "ite(this);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un array de float dans le packet à envoyer\r\n" +
                    "\t\t */\r\n\t\tpublic function WriteArrayOfUInt16(value:Array):void\r\n\t\t{\r\n\t\t\tWriteInt3" +
                    "2(value.length);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i" +
                    ":int = 0; i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteUInt16(value[i] as uint);\r\n\t\t\t}" +
                    "\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Ecrit un array de float dans le packet à envoyer\r\n\t\t */\r\n\t" +
                    "\tpublic function WriteArrayOfInt16(value:Array):void\r\n\t\t{\r\n\t\t\tWriteInt32(value.l" +
                    "ength);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0;" +
                    " i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteInt16(value[i] as int);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t" +
                    "/*\r\n\t\t * Ecrit un array d\'entiers dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic func" +
                    "tion WriteArrayOfInt32(value:Array):void\r\n\t\t{\r\n\t\t\tWriteInt32(value.length);\r\n\t\t\t" +
                    "\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < value.l" +
                    "ength; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteInt32(value[i] as int);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecr" +
                    "it un array d\'entiers dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteAr" +
                    "rayOfUInt32(value:Array):void\r\n\t\t{\r\n\t\t\tWriteInt32(value.length);\r\n\t\t\t\r\n\t\t\tif(val" +
                    "ue.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < value.length; ++i)" +
                    "\r\n\t\t\t{\r\n\t\t\t\tWriteUInt32(value[i] as uint);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Ecrit un ar" +
                    "ray d\'entiers dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteArrayOfInt" +
                    "64(value:Array):void\r\n\t\t{\r\n\t\t\tWriteInt32(value.length);\r\n\t\t\t\r\n\t\t\tif(value.length" +
                    " == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < value.length; ++i)\r\n\t\t\t{\r\n\t" +
                    "\t\t\tWriteInt64(value[i] as Int64);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un array d\'enti" +
                    "ers dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteArrayOfUInt64(value:" +
                    "Array):void\r\n\t\t{\r\n\t\t\tWriteInt32(value.length);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t" +
                    "\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteU" +
                    "Int64(value[i] as UInt64);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un array de double dan" +
                    "s le packet à envoyer\r\n\t\t */\r\n\t\tpublic function WriteArrayOfDouble(value:Array):" +
                    "void\r\n\t\t{\r\n\t\t\tWriteInt32(value.length);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\tretu" +
                    "rn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteSingle(v" +
                    "alue[i] as Number);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Ecrit un array de float dans le p" +
                    "acket à envoyer\r\n\t\t */\r\n\t\tpublic function WriteArrayOfSingle(value:Array):void\r\n" +
                    "\t\t{\r\n\t\t\tWriteInt32(value.length);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\treturn;\r\n\t" +
                    "\t\t\t\r\n\t\t\tfor(var i:int = 0; i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteSingle(value[i" +
                    "] as Number);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un array de float dans le packet à " +
                    "envoyer\r\n\t\t */\r\n\t\tpublic function WriteArrayOfDateTime(value:Array):void\r\n\t\t{\r\n\t" +
                    "\t\tWriteInt32(value.length);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t" +
                    "\t\tfor(var i:int = 0; i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteDateTime(value[i] as" +
                    " Date);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un array de float dans le packet à envoye" +
                    "r\r\n\t\t */\r\n\t\tpublic function WriteArrayOfString(value:Array):void\r\n\t\t{\r\n\t\t\tWriteI" +
                    "nt32(value.length);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(va" +
                    "r i:int = 0; i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteString(value[i] as String);\r" +
                    "\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Ecrit un array de float dans le packet à envoyer\r\n\t\t */" +
                    "\r\n\t\tpublic function WriteArrayOfBoolean(value:Array):void\r\n\t\t{\r\n\t\t\tWriteInt32(va" +
                    "lue.length);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int" +
                    " = 0; i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteBoolean(value[i] as Boolean);\r\n\t\t\t}" +
                    "\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Writes an array of dynamic members to the buffer\r\n\t\t */\r\n\t\t" +
                    "public function WriteArrayOfDynamic(value:Array):void\r\n\t\t{\r\n\t\t\tWriteInt32(value." +
                    "length);\r\n\t\t\t\r\n\t\t\tif(value.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0" +
                    "; i < value.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tWriteDynamic(value[i] as Object);\r\n\t\t\t}\r\n\t\t}" +
                    "\r\n\r\n\t\t/*\r\n\t\t * Ecrit un array dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function" +
                    " WriteArray(value:Array):void\r\n\t\t{\r\n\t\t\tWriteInt32(value.length);\r\n\t\t\t\r\n\t\t\tif(val" +
                    "ue.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < value.length; ++i)" +
                    "\r\n\t\t\t{\r\n\t\t\t\tvar obj:Object = value[i];\r\n\t\t\t\tif(obj is IPacket )\r\n\t\t\t\t{\r\n\t\t\t\t\t(ob" +
                    "j as IPacket).write(this)\t\r\n\t\t\t\t}\r\n\t\t\t\telse if(obj is IEntity )\r\n\t\t\t\t{\r\n\t\t\t\t\t(ob" +
                    "j as IEntity).write(this)\t\r\n\t\t\t\t}\r\n\t\t\t\telse \r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new Error(\"Unabl" +
                    "e to write, the array contains unknown elements\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\r\n\t}\r\n" +
                    "}");
            this.Write(" ");
            
            #line 9 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 10 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "PacketReader") { 
            
            #line default
            #line hidden
            this.Write(" ");
            this.Write("package spike\r\n{\r\n\timport spike.*;\r\n\timport spike.packets.*;\r\n\timport flash.utils" +
                    ".ByteArray;\r\n\timport flash.utils.getDefinitionByName;\r\n\t\r\n\tpublic class PacketRe" +
                    "ader\r\n\t{\r\n\t\t// internal buffer\r\n\t\tpublic var buffer:ByteArray;\r\n\t\t\r\n\t\tpublic fun" +
                    "ction PacketReader(bufferToRead:ByteArray)\r\n\t\t{\r\n\t\t\tbuffer = bufferToRead;\r\n\t\t}\r" +
                    "\n\r\n\t\t/*\r\n\t\t * Décompresse le reste de buffer\r\n\t\t */\r\n\t\tpublic function decompres" +
                    "s():void\r\n\t\t{\t\r\n\t\t\tbuffer = LZF.instance.decompress(buffer, buffer.length);\r\n\t\t\t" +
                    "buffer.position = 0;\t\t\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Lit l\'opération (le ID de packet)\r\n\t\t " +
                    "*/\r\n\t\tpublic function ReadOperation():int\r\n\t\t{\r\n\t\t\treturn buffer.readShort();\r\n\t" +
                    "\t}\r\n\r\n\t\t/*\r\n\t\t * Lit un entier 16bit dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic f" +
                    "unction ReadUInt16():Number\r\n\t\t{\r\n\t\t\treturn buffer.readShort();\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n" +
                    "\t\t * Lit un entier 16bit dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function Read" +
                    "Int16():Number\r\n\t\t{\r\n\t\t\treturn buffer.readShort();\r\n\t\t}\r\n\t\t\r\n\r\n\t\t/*\r\n\t\t * Lit un" +
                    " entier dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function ReadInt32():int\r\n\t\t{\r" +
                    "\n\t\t\treturn buffer.readInt();\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Lit un octet dans le packet à " +
                    "envoyer\r\n\t\t */\r\n\t\tpublic function ReadByte():uint\r\n\t\t{\r\n\t\t\treturn buffer.readUns" +
                    "ignedByte();\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Lit un octet dans le packet à envoyer\r\n\t\t */\r\n" +
                    "\t\tpublic function ReadSByte():int\r\n\t\t{\r\n\t\t\treturn buffer.readByte();\r\n\t\t}\r\n\t\t\r\n\t" +
                    "\t/*\r\n\t\t * Lit un entier dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function ReadN" +
                    "umber():Number\r\n\t\t{\r\n\t\t\treturn buffer.readInt();\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Lit un doubl" +
                    "e dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function ReadDouble():Number\r\n\t\t{\r\n\t" +
                    "\t\treturn buffer.readDouble();\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Lit un single dans le packet à " +
                    "envoyer\r\n\t\t */\r\n\t\tpublic function ReadSingle():Number\r\n\t\t{\r\n\t\t\treturn buffer.rea" +
                    "dFloat();\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Lit un single dans le packet à envoyer\r\n\t\t */\r\n\t\tpu" +
                    "blic function ReadInt64():Int64\r\n\t\t{\r\n\t\t\tvar result:Int64 = new Int64();\r\n\t\t\tres" +
                    "ult.low  = ReadUInt32();\r\n\t\t\tresult.high = ReadInt32();\r\n\t\t\treturn result;\r\n\t\t}\r" +
                    "\n\r\n\t\t/*\r\n\t\t * Reads a 64-bit unsigned integer\r\n\t\t */\r\n\t\tpublic function ReadUInt" +
                    "64():UInt64\r\n\t\t{\r\n\t\t\tvar result:UInt64 = new UInt64();\r\n\t\t\tresult.low  = ReadUIn" +
                    "t32();\r\n\t\t\tresult.high = ReadUInt32();\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t/*\r\n\t\t" +
                    " * Lit une valeur booleene dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function Re" +
                    "adBoolean():Boolean\r\n\t\t{\r\n\t\t\treturn buffer.readBoolean();\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * L" +
                    "it une entier non-signé dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function ReadU" +
                    "Int32():uint\r\n\t\t{\r\n\t\t\treturn buffer.readUnsignedInt();\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Lit " +
                    "une date dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function ReadDateTime():Date\r" +
                    "\n\t\t{\r\n\t\t\tvar year:int = buffer.readShort();\r\n\t\t\tvar month:int = buffer.readShort" +
                    "();\r\n\t\t\tvar date:int = buffer.readShort();\r\n\t\t\tvar hour:int = buffer.readShort()" +
                    ";\r\n\t\t\tvar minute:int = buffer.readShort();\r\n\t\t\tvar second:int = buffer.readShort" +
                    "();\r\n\t\t\tvar millisecond:int = buffer.readShort();\r\n\t\t\t\r\n\t\t\treturn new Date(year," +
                    "month,date,hour,minute,second, millisecond);\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * Lit une chaîne" +
                    " UTF8 dans le packet à envoyer\r\n\t\t */\r\n\t\tpublic function ReadString():String\r\n\t\t" +
                    "{\r\n\t\t\tvar stringBuffer:ByteArray = new ByteArray();\r\n\t\t\tvar length:int = buffer." +
                    "readInt();\r\n\t\t\t\r\n\t\t\tif(length > 0)\r\n\t\t\t{\r\n\t\t\t\tbuffer.readBytes(stringBuffer,0,le" +
                    "ngth);\r\n\t\t\t\treturn stringBuffer.readUTFBytes(length);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t" +
                    "return \"\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Reads a dynamic value (of the supported typ" +
                    "es)\r\n\t\t */\r\n\t\tpublic function ReadDynamic():Object\r\n\t\t{\r\n            if (ReadByt" +
                    "e() == 1)\r\n            {\r\n                var type:String = ReadString();\r\n     " +
                    "           switch (type)\r\n                {\r\n                    case \"Byte\": re" +
                    "turn ReadByte();\r\n                    case \"Int16\": return ReadInt16();\r\n       " +
                    "             case \"Int32\": return ReadInt32();\r\n                    case \"Int64\"" +
                    ": return ReadInt64();\r\n                    case \"UInt16\": return ReadUInt16();\r\n" +
                    "                    case \"UInt32\": return ReadUInt32();\r\n                    cas" +
                    "e \"UInt64\": return ReadUInt64();\r\n                    case \"Boolean\": return Rea" +
                    "dBoolean();\r\n                    case \"Single\": return ReadSingle();\r\n          " +
                    "          case \"Double\": return ReadDouble();\r\n                    case \"DateTim" +
                    "e\": return ReadDateTime();\r\n                    case \"String\": return ReadString" +
                    "();\r\n                    default: return null;\r\n                }\r\n            }" +
                    "\r\n            return null;\r\n        }\r\n\r\n\t\t\r\n\t\t/**\r\n\t\t * Lit et remplit l\'instan" +
                    "ce de IPacket de données (renvoit le même packet)\r\n\t\t *  Utilisation:  var packe" +
                    "t:MonPacket = reader.ReadPacket(new MonPacket());\r\n\t\t */\r\n\t\tpublic function Read" +
                    "Packet(value:IPacket):IPacket\r\n\t\t{\r\n\t\t\tvalue.read(this);\r\n\t\t\treturn value;\r\n\t\t}\r" +
                    "\n\t\t\r\n\t\t\t\t\r\n\t\t/**\r\n\t\t * Lit et remplit l\'instance de IEntity de données (renvoit " +
                    "le même packet)\r\n\t\t *  Utilisation:  var packet:MonPacket = reader.ReadPacket(ne" +
                    "w MonPacket());\r\n\t\t */\r\n\t\tpublic function ReadEntity(value:IEntity):IEntity\r\n\t\t{" +
                    "\r\n\t\t\tvalue.read(this);\r\n\t\t\treturn value;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Reads a byte arra" +
                    "y from the buffer\r\n\t\t */\r\n\t\tpublic function ReadByteArray():ByteArray\r\n\t\t{\r\n\t\t\tv" +
                    "ar len:int = buffer.readInt();\r\n\t\t\tvar result:ByteArray = new ByteArray();\r\n\t\t\tb" +
                    "uffer.readBytes(result,0,len);\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Reads an" +
                    " array from the buffer\r\n\t\t */\r\n\t\tpublic function ReadArrayOfEntity(className:Str" +
                    "ing):Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32();\r\n\t\t\tvar classType:Class = Clas" +
                    "s(getDefinitionByName(className));\r\n\t\t\t\r\n\t\t\tvar resultArray:Array = new Array();" +
                    "\r\n\t\t\t\r\n\t\t\tif(length == 0)\r\n\t\t\t\treturn resultArray;  // vide\r\n\t\t\t\t\r\n\t\t\tfor(var i:" +
                    "int = 0; i < length; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar entityInstance:IEntity = new classType(" +
                    ");\r\n\t\t\t\tresultArray.push( ReadEntity(entityInstance) );\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\treturn r" +
                    "esultArray;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Reads an array from the buffer\r\n\t\t */\r\n\t\tpubli" +
                    "c function ReadArrayOfNumber():Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32();\r\n\t\t\t" +
                    "var resultArray:Array = new Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < length; ++" +
                    "i)\r\n\t\t\t\tresultArray.push( ReadNumber() );\r\n\t\t\t\r\n\t\t\treturn resultArray;\r\n\t\t}\r\n\r\n\t" +
                    "\t/**\r\n\t\t * Reads an array from the buffer\r\n\t\t */\r\n\t\tpublic function ReadArrayOfU" +
                    "Int16():Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32();\r\n\t\t\tvar resultArray:Array =" +
                    " new Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < length; ++i)\r\n\t\t\t\tresultArray.pus" +
                    "h( ReadUInt16() );\r\n\t\t\t\r\n\t\t\treturn resultArray;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Reads an arr" +
                    "ay from the buffer\r\n\t\t */\r\n\t\tpublic function ReadArrayOfInt16():Array\r\n\t\t{\r\n\t\t\tv" +
                    "ar length:int = ReadInt32();\r\n\t\t\tvar resultArray:Array = new Array();\r\n\t\t\t\t\r\n\t\t\t" +
                    "for(var i:int = 0; i < length; ++i)\r\n\t\t\t\tresultArray.push( ReadInt16() );\r\n\t\t\t\r\n" +
                    "\t\t\treturn resultArray;\r\n\t\t}\r\n\r\n\t\t\r\n\t\t/**\r\n\t\t * Reads an array from the buffer\r\n\t" +
                    "\t */\r\n\t\tpublic function ReadArrayOfUInt32():Array\r\n\t\t{\r\n\t\t\tvar length:int = Read" +
                    "Int32();\r\n\t\t\tvar resultArray:Array = new Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i" +
                    " < length; ++i)\r\n\t\t\t\tresultArray.push( ReadUInt32() );\t\r\n\t\t\t\r\n\t\t\treturn resultAr" +
                    "ray;\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Reads an array from the buffer\r\n\t\t */\r\n\t\tpublic funct" +
                    "ion ReadArrayOfInt32():Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32();\r\n\t\t\tvar resu" +
                    "ltArray:Array = new Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < length; ++i)\r\n\t\t\t\t" +
                    "resultArray.push( ReadInt32() );\r\n\t\t\t\r\n\t\t\treturn resultArray;\r\n\t\t}\r\n\r\n\t\t\r\n\t\t/**\r" +
                    "\n\t\t * Reads an array from the buffer\r\n\t\t */\r\n\t\tpublic function ReadArrayOfUInt64" +
                    "():Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32();\r\n\t\t\tvar resultArray:Array = new " +
                    "Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < length; ++i)\r\n\t\t\t\tresultArray.push( Re" +
                    "adUInt64() );\t\r\n\t\t\t\r\n\t\t\treturn resultArray;\r\n\t\t}\r\n\r\n\t\t\r\n\t\t/**\r\n\t\t * Reads an arr" +
                    "ay from the buffer\r\n\t\t */\r\n\t\tpublic function ReadArrayOfInt64():Array\r\n\t\t{\r\n\t\t\tv" +
                    "ar length:int = ReadInt32();\r\n\t\t\tvar resultArray:Array = new Array();\r\n\t\t\t\t\r\n\t\t\t" +
                    "for(var i:int = 0; i < length; ++i)\r\n\t\t\t\tresultArray.push( ReadInt64() );\t\r\n\t\t\t\r" +
                    "\n\t\t\treturn resultArray;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Reads an array from the buffer\r\n\t\t *" +
                    "/\r\n\t\tpublic function ReadArrayOfSingle():Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt" +
                    "32();\r\n\t\t\tvar resultArray:Array = new Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < " +
                    "length; ++i)\r\n\t\t\t\tresultArray.push( ReadSingle() );\r\n\t\t\t\r\n\t\t\treturn resultArray;" +
                    "\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Reads an array from the buffer\r\n\t\t */\r\n\t\tpublic function Re" +
                    "adArrayOfDouble():Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32();\r\n\t\t\tvar resultArr" +
                    "ay:Array = new Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < length; ++i)\r\n\t\t\t\tresul" +
                    "tArray.push( ReadDouble() );\r\n\t\t\t\r\n\t\t\treturn resultArray;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Re" +
                    "ads an array from the buffer\r\n\t\t */\r\n\t\tpublic function ReadArrayOfBoolean():Arra" +
                    "y\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32();\r\n\t\t\tvar resultArray:Array = new Array()" +
                    ";\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < length; ++i)\r\n\t\t\t\tresultArray.push( ReadBoole" +
                    "an() );\r\n\t\t\t\r\n\t\t\treturn resultArray;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Reads an array from t" +
                    "he buffer\r\n\t\t */\r\n\t\tpublic function ReadArrayOfDateTime():Array\r\n\t\t{\r\n\t\t\tvar len" +
                    "gth:int = ReadInt32();\r\n\t\t\tvar resultArray:Array = new Array();\r\n\t\t\t\t\r\n\t\t\tfor(va" +
                    "r i:int = 0; i < length; ++i)\r\n\t\t\t\tresultArray.push( ReadDateTime() );\r\n\t\t\t\r\n\t\t\t" +
                    "return resultArray;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Reads an array from the buffer\r\n\t\t */\r" +
                    "\n\t\tpublic function ReadArrayOfString():Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32" +
                    "();\r\n\t\t\tvar resultArray:Array = new Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < le" +
                    "ngth; ++i)\r\n\t\t\t\tresultArray.push( ReadString() );\r\n\t\t\t\r\n\t\t\treturn resultArray;\r\n" +
                    "\t\t}\r\n\r\n\t\t/**\r\n\t\t * Reads an array from the buffer\r\n\t\t */\r\n\t\tpublic function Read" +
                    "ArrayOfDynamic():Array\r\n\t\t{\r\n\t\t\tvar length:int = ReadInt32();\r\n\t\t\tvar resultArra" +
                    "y:Array = new Array();\r\n\t\t\t\t\r\n\t\t\tfor(var i:int = 0; i < length; ++i)\r\n\t\t\t\tresult" +
                    "Array.push( ReadDynamic() );\r\n\t\t\t\r\n\t\t\treturn resultArray;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n}");
            this.Write(" ");
            
            #line 10 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 11 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "TcpChannel") { 
            
            #line default
            #line hidden
            this.Write(@"package spike 
{
	import flash.errors.IOError;
	import flash.events.*;
	import flash.utils.ByteArray;
    
	import mx.controls.Alert;
	import mx.events.*;
	import mx.messaging.channels.amfx.*;
    
	import spike.events.ConnectionEvent;
	import spike.events.SocketReceiveEvent;

");
            
            #line 14 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 foreach(var receive in Model.Receives){ 
            
            #line default
            #line hidden
            this.Write("\t[Event(name=\"");
            
            #line 14 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(receive.Name));
            
            #line default
            #line hidden
            this.Write("\", type=\"network.events.PacketReceiveEvent\")]\r\n");
            
            #line 15 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 } 
            
            #line default
            #line hidden
            this.Write("\t[Event(name=\"connected\", type=\"network.events.ConnectionEvent\")]\r\n\t[Event(name=\"" +
                    "disconnected\", type=\"network.events.ConnectionEvent\")]\r\n\t[Event(name=\"ioError\", " +
                    "type=\"flash.events.IOErrorEvent\")]\r\n\t[Event(name=\"securityError\", type=\"flash.ev" +
                    "ents.SecurityErrorEvent\")]\r\n\t[Event(name=\"progress\", type=\"flash.events.Progress" +
                    "Event\")]\r\n\tpublic class TcpChannel \r\n\t{    \t\r\n\t\t// Socket configuration\r\n\t\tpriva" +
                    "te var _socket:TcpSocket;\r\n\t\tprivate var _hostName:String = \"localhost\";\r\n\t\tpriv" +
                    "ate var _port:uint = 8002;\r\n        \r\n\t\t// Public properties\r\n\t\t[Bindable]\r\n\t\tpu" +
                    "blic function set hostName(value:String) :void { _hostName = value; }\r\n\t\tpublic " +
                    "function get hostName() : String { return _hostName; }\r\n        \r\n\t\t[Bindable]\r\n" +
                    "\t\tpublic function set port(value:uint) :void { _port = value; }\r\n\t\tpublic functi" +
                    "on get port() : uint { return _port; }\r\n        \r\n\t\t/**\r\n\t\t* Gets whether the co" +
                    "nnection was established or not\r\n\t\t*/\r\n\t\tpublic function get isConnected() :Bool" +
                    "ean { return _socket.connected; }\r\n        \r\n\t\tpublic function TcpChannel() \r\n\t\t" +
                    "{\r\n\t\t\tif(_socket == null)\r\n\t\t\t\t_socket = new TcpSocket(this);\r\n\t\t\tconfigureListe" +
                    "ners(_socket);\r\n\t\t}\r\n        \r\n\t\t/**\r\n\t\t* Connects the channel to the remote end" +
                    "-point.\r\n\t\t*/\r\n\t\tpublic function connect():void\r\n\t\t{\r\n\t\t\tif(_socket.connected !=" +
                    " true)\r\n\t\t\t\t_socket.connect(hostName, port);\r\n\t\t}\r\n        \r\n\t\t/**\r\n\t\t* Disconne" +
                    "cts the channel from the remote end-point.\r\n\t\t*/\r\n\t\tpublic function disconnect()" +
                    ":void \r\n\t\t{\r\n\t\t\t_socket.close();\r\n\t\t}  \r\n\r\n\t\t/**\r\n\t\t* Invoked when the data is r" +
                    "eceived\r\n\t\t*/\r\n\t\tprotected function onReceive(event:SocketReceiveEvent):void\r\n\t\t" +
                    "{\r\n\t\t\tswitch(event.Operation)\r\n\t\t\t{\r\n");
            
            #line 73 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 foreach(var receive in Model.Receives){ 
            
            #line default
            #line hidden
            this.Write("\t\t\t\tcase \"");
            
            #line 74 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(receive.Id.ToString("X").ToUpper()));
            
            #line default
            #line hidden
            this.Write("\": {\r\n\t\t\t\t\tvar packet:");
            
            #line 75 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(receive.Name));
            
            #line default
            #line hidden
            this.Write(" = new ");
            
            #line 75 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(receive.Name));
            
            #line default
            #line hidden
            this.Write("();\r\n\t\t\t\t\tpacket.read(event.Reader);\r\n\t\t\t\t\tdispatchEvent(new PacketReceiveEvent(\"" +
                    "");
            
            #line 77 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(receive.Name.CamelCase()));
            
            #line default
            #line hidden
            this.Write("\", packet));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n");
            
            #line 80 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 } 
            
            #line default
            #line hidden
            this.Write(@"			}
		}
   
		private function configureListeners(dispatcher:IEventDispatcher):void 
		{
			dispatcher.addEventListener(""socketReceive"", onReceive);
			dispatcher.addEventListener(Event.CLOSE, closeHandler);
			dispatcher.addEventListener(Event.CONNECT, connectHandler);
			dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
			dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
			dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
		}
		   
		private function closeHandler(event:Event):void {
			dispatchEvent(new network.events.ConnectionEvent(""disconnected""));
		}
   
		private function connectHandler(event:Event):void {
			dispatchEvent(new network.events.ConnectionEvent(""connected""));
		}
   
		private function ioErrorHandler(event:IOErrorEvent):void {
			dispatchEvent(event);
		}
   
		private function progressHandler(event:ProgressEvent):void {
			dispatchEvent(event);
		}
   
		private function securityErrorHandler(event:SecurityErrorEvent):void {
			dispatchEvent(event);
		}


		
");
            
            #line 116 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 foreach(var send in Model.Sends){ 
            
            #line default
            #line hidden
            this.Write("\t\t\r\n\t\tpublic function ");
            
            #line 117 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(send.Name.CamelCase()));
            
            #line default
            #line hidden
            this.Write("(");
            
            #line 117 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
	
	var first = true;
	foreach(var member in send.Members){
		if(!first){
			Write(", ");
		}

		Write(member.Name.CamelCase());
		Write(":");
		Write(AS3Builder.GetNativeType(member));
		first = false;
	}

            
            #line default
            #line hidden
            this.Write("):void {\r\n\t\t\tvar writer:PacketWriter = new PacketWriter();\r\n");
            
            #line 131 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 foreach(var member in send.Members){ 
            
            #line default
            #line hidden
            this.Write("\t\t\twriter.Write");
            
            #line 132 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Type));
            
            #line default
            #line hidden
            this.Write("(");
            
            #line 132 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Name.CamelCase()));
            
            #line default
            #line hidden
            this.Write(")\r\n");
            
            #line 133 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 } 
            
            #line default
            #line hidden
            
            #line 134 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 if(send.Compressed){ 
            
            #line default
            #line hidden
            this.Write("\t\t\twriter.compress();\r\n");
            
            #line 136 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 } 
            
            #line default
            #line hidden
            this.Write("\r\n\t\t\t_socket.send(\"");
            
            #line 138 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(send.Id.ToString("X").ToUpper()));
            
            #line default
            #line hidden
            this.Write("\", writer);\r\n\t\t}\r\n");
            
            #line 140 "D:\Workspace\Spike.Build\Spike.Build.AS3\TcpChannel.t4"
 } 
            
            #line default
            #line hidden
            this.Write("\r\n\r\n    }\r\n}");
            
            #line 11 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 12 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "TcpSocket") { 
            
            #line default
            #line hidden
            this.Write("package spike\r\n{\r\n    import flash.errors.*;\r\n    import flash.events.*;\r\n    imp" +
                    "ort flash.events.TimerEvent;\r\n    import flash.net.Socket;\r\n    import flash.uti" +
                    "ls.ByteArray;\r\n    import flash.utils.Timer;\r\n    \r\n    import mx.controls.Alert" +
                    ";\r\n    \r\n    import spike.events.SocketReceiveEvent;\r\n\r\n\t[Event(name=\"socketRece" +
                    "ive\", type=\"ResultEvent\")]\r\n\tpublic class TcpSocket extends Socket \r\n\t{\r\n\t\t// Pr" +
                    "ivate members\r\n\t\tprivate var channel:TcpChannel;\r\n\t\tprivate var buffer:ByteArray" +
                    " = new ByteArray();\r\n\t\tprivate var partialRecord:Boolean = false;\r\n\r\n\r\n\r\n\t    pu" +
                    "blic function TcpSocket(channel:TcpChannel) \r\n\t    {\r\n\t        super();\r\n\t\t\tthis" +
                    ".channel = channel;\r\n\t\t\tthis.addEventListener(ProgressEvent.SOCKET_DATA, receive" +
                    ");\r\n\t    }\r\n\t    \r\n\r\n\t    public function send(operationKey:String, packet:Packe" +
                    "tWriter):void \r\n\t    {\r\n\t\t\t// Compile the packet to a stream\r\n\t\t\tvar stream:Byte" +
                    "Array = new ByteArray();\r\n\t\t\twriteLength(stream, packet.buffer.length + Packet.H" +
                    "EADER_KEY_SIZE);\r\n\t\t\twriteKey(stream, operationKey);\r\n\r\n\t\t\t// Write the data\r\n  " +
                    "          stream.writeBytes(packet.buffer,0, packet.buffer.length);\r\n\t\t\t\r\n\t\t\t// " +
                    "Encode it if there is a specific encoder\r\n\t\t\tif(channel.packetEncoder != null)\r\n" +
                    "\t\t\t\tstream = channel.packetEncoder.encodeOutgoingPacket(channel, stream, stream." +
                    "length);\r\n\t\t\t\r\n\t\t\t// Send\r\n\t\t\tthis.writeBytes(stream, 0, stream.length);\r\n      " +
                    "      flush(); \r\n\t    }\r\n\t    \r\n\t\tpublic function receive(event:ProgressEvent):v" +
                    "oid \r\n\t\t{\r\n\t\t\tvar data:ByteArray = new ByteArray();\r\n\t\t\tif(partialRecord)\r\n\t\t\t{\r" +
                    "\n\t\t\t\tbuffer.readBytes(data, 0, buffer.length);\r\n\t\t\t\tpartialRecord = false;\r\n\t\t\t}" +
                    "\r\n\t\t\t\r\n\t\t\tif(channel.packetEncoder == null)\r\n\t\t\t{\r\n\t\t\t\tthis.readBytes(data, data" +
                    ".length, this.bytesAvailable);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar rawRecv:ByteArray =" +
                    " new ByteArray();\r\n\t\t\t\tthis.readBytes(rawRecv, 0, this.bytesAvailable);\r\n\t\t\t\tvar" +
                    " decoded:ByteArray = this.channel.packetEncoder.decodeIncomingPacket(this.channe" +
                    "l, rawRecv, rawRecv.length);\r\n\t\t\t\tif(decoded != null)\r\n\t\t\t\t\tdata.writeBytes(deco" +
                    "ded, data.length, decoded.length);\r\n\t\t\t\tdata.position = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Whi" +
                    "le we have data to read\r\n\t\t\twhile(data.position < data.length)\r\n\t\t\t{\r\n\t\t\t\tif(dat" +
                    "a.length - data.position < Packet.HEADER_LENGTH_SIZE)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Bad situat" +
                    "ion, we don\'t even have the full packet here.\r\n\t\t\t\t\t// Read the partial packet (" +
                    "few bytes)\r\n\t\t\t        buffer = new ByteArray();\r\n\t\t\t        data.readBytes(buff" +
                    "er, 0, data.length - data.position);\r\n\t\t\t        partialRecord = true;\r\n\t\t\t     " +
                    "   break;\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t    var Length:int = data.readInt() + Packet.HEADER_" +
                    "LENGTH_SIZE;\r\n\t\t\t\tdata.position -= Packet.HEADER_LENGTH_SIZE;\r\n\t\t\t\t\r\n\t\t\t    // I" +
                    "f we have enough data to form a full packet.\r\n\t\t\t    if(Length <= (data.length -" +
                    " data.position))\r\n\t\t\t    {\r\n\t\t\t        // Read the operation and read the actual" +
                    " message into a new buffer\r\n\t\t\t        var messageLength:int = readLength(data);" +
                    " // UNUSED\r\n\t\t\t        var operation:String  = readKey(data);\r\n\t\t\t        \r\n\t\t\t " +
                    "       // New buffer for the packet\r\n\t\t\t        var packet:ByteArray = new ByteA" +
                    "rray();\r\n\t\t\t        data.readBytes(packet,0, Length - Packet.HEADER_SIZE);\r\n\t\t\t " +
                    "       packet.position = 0;\r\n\t\t\t\r\n\t\t\t\t\t// Create the reader and fire the event\r\n" +
                    "\t\t\t    \tvar reader:PacketReader = new PacketReader(packet);\r\n\t\t\t    \tdispatchEve" +
                    "nt(new SocketReceiveEvent(\"socketReceive\", operation, reader ));\r\n\t\t\t    }\r\n\t\t\t " +
                    "   else \r\n\t\t\t    {\r\n\t\t\t        // Read the partial packet\r\n\t\t\t        buffer = n" +
                    "ew ByteArray();\r\n\t\t\t        data.readBytes(buffer,0,data.length - data.position)" +
                    ";\r\n\t\t\t        partialRecord = true;\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t\r\n\t\t/**\r\n\t\t" +
                    " * Writes an ASCII string to the underlying socket\r\n\t\t */\r\n\t\tpublic function wri" +
                    "teAsciiString(value:String):void\r\n\t\t{\r\n\t\t\t// Naive ASCII conversion for Linux co" +
                    "mpatibility\r\n\t\t\tfor(var i:int=0; i<value.length; ++i)\r\n\t\t\t\tthis.writeByte(value." +
                    "charCodeAt(i));\t\r\n\t\t}\r\n\t\t \r\n\t\t /**\r\n\t\t  * Writes the packet length to the stream" +
                    ".\r\n\t\t  */  \r\n\t\tprivate function writeLength(stream:ByteArray, value:int):void\r\n\t" +
                    "\t{\r\n\t\t\tstream.writeUnsignedInt(value);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t  * Writes the packet op" +
                    "eration identifier to the stream.\r\n\t\t  */  \r\n\t\tprivate function writeKey(stream:" +
                    "ByteArray, value:String):void\r\n\t\t{\r\n\t\t\tvar buffer:ByteArray = new ByteArray();\r\n" +
                    "\t\t\tfor(var i:int=0; i<value.length; i+=2)\r\n\t\t\t\tbuffer[i / 2] = parseInt(value.su" +
                    "bstr(i,2), 16);\r\n\r\n\t\t\tstream.writeBytes(buffer,0, buffer.length);\r\n\t\t}\r\n\r\n\t\t /**" +
                    "\r\n\t\t  * Reads the packet length from the stream.\r\n\t\t  */  \r\n\t\tprivate function r" +
                    "eadLength(stream:ByteArray):int\r\n\t\t{\r\n\t\t\treturn stream.readInt();\r\n\t\t}\r\n\r\n\t\t /**" +
                    "\r\n\t\t  * Reads the packet operation identifier from the stream.\r\n\t\t  */  \r\n\t\tpriv" +
                    "ate function readKey(stream:ByteArray):String\r\n\t\t{\r\n            var s:String = \"" +
                    "\";\r\n            for (var i:uint=0; i < Packet.HEADER_KEY_SIZE; i++)\r\n\t\t\t{\r\n\t\t\t\tv" +
                    "ar byte:uint = stream.readByte();\r\n                s += (\"0\" + byte.toString(16)" +
                    ").substr(-2,2);\r\n\t\t\t}\r\n\t\t\ts = s.toUpperCase();\r\n            return s;\r\n\t\t}\r\n\r\n\r\n" +
                    "\t}\r\n}");
            
            #line 12 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 13 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "CustomPacket") { 
            
            #line default
            #line hidden
            this.Write("package spike.packets\r\n{\r\n\timport flash.utils.ByteArray;\r\n\timport spike.*;\r\n\timpo" +
                    "rt spike.packets.*;\r\n\r\n\t[RemoteClass(alias=\"");
            
            #line 7 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(TargetOperation.Name));
            
            #line default
            #line hidden
            this.Write("\")]\r\n\tpublic class ");
            
            #line 8 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(TargetOperation.Name));
            
            #line default
            #line hidden
            this.Write(" extends Packet implements IPacket\r\n\t{\r\n\t\tpublic function ");
            
            #line 10 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(TargetOperation.Name));
            
            #line default
            #line hidden
            this.Write("()\r\n\t\t{\r\n\t\t\tsuper(\"");
            
            #line 12 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(TargetOperation.Id.ToString("X").ToUpper()));
            
            #line default
            #line hidden
            this.Write("\");\r\n\t\t}\r\n\r\n");
            
            #line 15 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
 foreach(var member in TargetOperation.Members){ 
            
            #line default
            #line hidden
            this.Write("\t\tprivate var _");
            
            #line 16 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Name));
            
            #line default
            #line hidden
            this.Write(":");
            
            #line 16 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(AS3Builder.GetNativeType(member)));
            
            #line default
            #line hidden
            this.Write(";\r\n\t\t[Bindable]\r\n\t\tpublic function set ");
            
            #line 18 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Name.CamelCase()));
            
            #line default
            #line hidden
            this.Write("(value:");
            
            #line 18 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(AS3Builder.GetNativeType(member)));
            
            #line default
            #line hidden
            this.Write("):void { _");
            
            #line 18 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Name));
            
            #line default
            #line hidden
            this.Write(" = value; }\r\n\t\tpublic function get ");
            
            #line 19 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Name.CamelCase()));
            
            #line default
            #line hidden
            this.Write("():");
            
            #line 19 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(AS3Builder.GetNativeType(member)));
            
            #line default
            #line hidden
            this.Write(" { return _");
            
            #line 19 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Name));
            
            #line default
            #line hidden
            this.Write("; }\r\n\r\n");
            
            #line 21 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
 } 
            
            #line default
            #line hidden
            this.Write("\t\t\r\n\r\n\t\t/**\r\n\t\t* Writes (serializes) the packet to the specified packet writer.\r\n" +
                    "\t\t*/\r\n\t\tpublic function write(writer:PacketWriter):void\r\n\t\t{\r\n");
            
            #line 28 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
 foreach(var member in TargetOperation.Members){ 
            
            #line default
            #line hidden
            this.Write("\t\t\twriter.Write");
            
            #line 29 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Type));
            
            #line default
            #line hidden
            this.Write("(_");
            
            #line 29 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Name));
            
            #line default
            #line hidden
            this.Write(");\r\n");
            
            #line 30 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
 } 
            
            #line default
            #line hidden
            this.Write("\t\t}\r\n\r\n\t\t/**\r\n\t\t* Reads (deserializes) the packet from the specified packet reade" +
                    "r.\r\n\t\t*/\r\n\t\tpublic function read(reader:PacketReader):void\r\n\t\t{\r\n");
            
            #line 38 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
 foreach(var member in TargetOperation.Members){ 
            
            #line default
            #line hidden
            this.Write("\t\t\t_");
            
            #line 39 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Name));
            
            #line default
            #line hidden
            this.Write(" = reader.Read");
            
            #line 39 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
            this.Write(this.ToStringHelper.ToStringWithCulture(member.Type));
            
            #line default
            #line hidden
            this.Write("();\r\n");
            
            #line 40 "D:\Workspace\Spike.Build\Spike.Build.AS3\Packet.t4"
 } 
            
            #line default
            #line hidden
            this.Write("\t\t}\r\n\t}\r\n}\r\n");
            
            #line 13 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            this.Write("\r\n");
            
            #line 15 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "Int64") { 
            
            #line default
            #line hidden
            this.Write("package spike\r\n{\r\n    public final class Int64 \r\n\t{\r\n        public var high:int;" +
                    "\r\n        public var low:uint;\r\n    }\r\n}");
            
            #line 15 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 16 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "UInt64") { 
            
            #line default
            #line hidden
            this.Write("package spike\r\n{\r\n    public final class UInt64 \r\n\t{\r\n\t\tpublic var high:uint;\r\n\t\t" +
                    "public var low:uint;\r\n    }\r\n}");
            
            #line 16 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 17 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "IEntity") { 
            
            #line default
            #line hidden
            this.Write("package spike\r\n{\r\n\timport flash.utils.ByteArray;\r\n\t\r\n\tpublic interface IEntity\r\n\t" +
                    "{\r\n\t\tfunction write(writer:PacketWriter):void;\r\n\t\tfunction read(reader:PacketRea" +
                    "der):void;\r\n\t}\r\n}");
            
            #line 17 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 18 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "IPacket") { 
            
            #line default
            #line hidden
            this.Write("package spike\r\n{\r\n\timport flash.utils.ByteArray;\r\n\t\r\n\tpublic interface IPacket ex" +
                    "tends IEntity\r\n\t{\r\n\r\n\t}\r\n}");
            
            #line 18 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 19 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "Packet") { 
            
            #line default
            #line hidden
            this.Write(@"package spike
{
	public class Packet
	{
	    /**
         * The number of bytes in the packet header
         */     
        public static const HEADER_SIZE : Number = 8;

        /**
         * The number of bytes in the length number of the header
         */     
        public static const HEADER_LENGTH_SIZE : Number = 4;

        /**
         * The number of bytes in the operation identifier of the header
         */     
        public static const HEADER_KEY_SIZE : Number = 4;



		private var _operation:String;

		public function set operation(value:String) :void { _operation = value; }
        public function get operation() : String { return _operation; }
        
		public function Packet(operation:String)
		{
			_operation = operation;
		}

	}
}");
            
            #line 19 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 20 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "MxmlChannel") { 
            
            #line default
            #line hidden
            this.Write(@"package spike.mxml
{
	import mx.core.IMXMLObject;
	import mx.core.mx_internal;
	import mx.resources.IResourceManager;
	import mx.resources.ResourceManager;
	import mx.rpc.mxml.IMXMLSupport;
	
	import spike.TcpChannel;
	
	use namespace mx_internal;

	public class MxmlChannel extends spike.TcpChannel implements IMXMLObject
	{
	    private var resourceManager:IResourceManager = ResourceManager.getInstance();
		private var document:Object; //keep the document for validation
		private var id:String; //need to know our own id for validation

		public function MxmlChannel()
		{
		}
		

		/**
		 * Called after the implementing object has been created and all component
		 * properties specified on the MXML tag have been initialized. 
		 */
		public function initialized(document:Object, id:String):void
		{
		    this.id = id;
		    this.document = document;
		}
		
	}
}");
            
            #line 20 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 21 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "ConnectionEvent") { 
            
            #line default
            #line hidden
            this.Write("package spike.events\r\n{\r\n\timport flash.events.Event;\r\n \r\n\tpublic class Connection" +
                    "Event extends Event\r\n\t{\r\n\t\tpublic function ConnectionEvent( type:String ) { supe" +
                    "r(type); }   \r\n\t}\r\n}");
            
            #line 21 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 22 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "PacketReceiveEvent") { 
            
            #line default
            #line hidden
            this.Write(@"package spike.events
{
	import flash.events.Event;
	
	public class PacketReceiveEvent extends Event
	{
		public var data:Object;
		public function PacketReceiveEvent( type:String, dataReceived:Object )
		{
			data = dataReceived;
			super(type);
		}

	}
}	
");
            
            #line 22 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            
            #line 23 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 if(Target == null || Target == "SocketReceiveEvent") { 
            
            #line default
            #line hidden
            this.Write(@"package spike.events
{
	import flash.events.Event;
	
	import spike.PacketReader;
	
	public class SocketReceiveEvent extends Event
	{
		public var Reader:PacketReader;
		public var Operation:String;
		public var Handled:Boolean = false;
		
		public function SocketReceiveEvent(type:String, operation:String, reader:PacketReader)
		{
			Reader = reader;
			Operation = operation;
			super(type);
		}

	}
}	");
            
            #line 23 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 } 
            
            #line default
            #line hidden
            this.Write("\r\n\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }
        
        #line 27 "D:\Workspace\Spike.Build\Spike.Build.AS3\AS3Template.tt"
 public void Clear(){
	GenerationEnvironment.Clear();
} 
        
        #line default
        #line hidden
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "12.0.0.0")]
    public class AS3TemplateBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
