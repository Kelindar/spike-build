// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Spike.Build.Java
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "C:\Users\Fabian\Desktop\Projects\GitHub\spike-build\Spike.Build.Java\AbstractTcpChannelTemplate.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public partial class AbstractTcpChannelTemplate : AbstractTcpChannelTemplateBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("package com.misakai.spike.network;\r\n\r\nimport java.io.IOError;\r\nimport java.io.IOE" +
                    "xception;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.net.InetSoc" +
                    "ketAddress;\r\nimport java.net.Socket;\r\nimport java.net.UnknownHostException;\r\nimp" +
                    "ort java.nio.ByteBuffer;\r\nimport java.nio.channels.ClosedByInterruptException;\r\n" +
                    "import java.nio.channels.SocketChannel;\r\nimport java.util.ArrayList;\r\nimport jav" +
                    "a.util.Date;\r\nimport java.util.GregorianCalendar;\r\n\r\n/**\r\n * Represents a TCP/IP" +
                    " network channel\r\n */\r\npublic abstract class AbstractTcpChannel {\t\r\n\t\r\n\tprivate " +
                    "Socket socket;\r\n\tprotected SocketChannel socketChannel;\r\n\tprotected ByteBuffer r" +
                    "eceiveBuffer;\r\n\tprotected ByteBuffer sendBuffer;\r\n\tprivate Thread backgroundThre" +
                    "ad; \r\n\t\r\n\t/**\r\n\t * List of listener invoke when channel is connected to the remo" +
                    "te server\r\n\t */\r\n\tpublic final ArrayList<ConnectionHandler> onConnect = new Arra" +
                    "yList<ConnectionHandler>();\r\n\t/**\r\n\t * List of listener invoke when channel is d" +
                    "isconnected to the remote server\r\n\t */\r\n\tpublic final ArrayList<DisconnectionHan" +
                    "dler> onDisconnect = new ArrayList<DisconnectionHandler>();\r\n\r\n\t/**\r\n\t * Constru" +
                    "cts a TCP/IP network channel.\r\n\t */\r\n\tpublic AbstractTcpChannel(){\r\n\t\t//ThreadFa" +
                    "ctory factory = Executors.defaultThreadFactory();\r\n\t\t//ExecutorService executor " +
                    "= Executors.newFixedThreadPool(numberOfThreads);\r\n\t\t\r\n\t\tbackgroundThread = new T" +
                    "hread(new Runnable() {\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\ttry {\r\n\t\t\t\t" +
                    "\twhile(true){\r\n\t\t\t\t\t\treceiveBuffer.clear();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tsocketChannel.read(re" +
                    "ceiveBuffer);\r\n\t\t\t\t\t\tint packetSize = receiveBuffer.getInt(0);\t\t\t\t\t\t \r\n\t\t\t\t\t\t\r\n\t" +
                    "\t\t\t\t\twhile(packetSize + 4 > receiveBuffer.position())\r\n\t\t\t\t\t\t\tsocketChannel.read" +
                    "(receiveBuffer);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tonReceive(receiveBuffer.getInt(4)); //give the k" +
                    "ey\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (ClosedByInterruptException e) {\r\n\t\t\t\t\t//disconnect crea" +
                    "te an IO exception\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tdisconnect();\r\n\t\t\t\t} \t\t\t" +
                    "\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Performs a connection to the remote server\r\n\t * " +
                    "@param host Hostname to connect to\r\n\t * @param port Destination Port to connect " +
                    "through\r\n\t * @throws UnknownHostException\r\n\t * @throws IOException\r\n\t */\r\n\tpubli" +
                    "c void connect(String host, int port) throws UnknownHostException, IOException{\r" +
                    "\n\t\tsocketChannel = SocketChannel.open();\r\n\t\tsocketChannel.connect(new InetSocket" +
                    "Address(host, port));\r\n\t\tsocket = socketChannel.socket();\r\n\t\treceiveBuffer = Byt" +
                    "eBuffer.allocate(socket.getReceiveBufferSize());\r\n\t\tsendBuffer = ByteBuffer.allo" +
                    "cate(socket.getSendBufferSize());\r\n\t\t\r\n\t\t//Raise IConnectionHandlers\r\n\t\tfor (Con" +
                    "nectionHandler connectionHandler : onConnect)\r\n\t\t\tconnectionHandler.onConnect();" +
                    "\r\n\t\t\r\n\t\tbackgroundThread.start();\r\n\t}\t\r\n\t\r\n\t/**\r\n\t * Disconnects from the server" +
                    "\r\n\t */\r\n\tpublic void disconnect() {\r\n\t\ttry {\r\n\t\t\tif(Thread.currentThread() != ba" +
                    "ckgroundThread && backgroundThread.isAlive())\r\n\t\t\t\tbackgroundThread.interrupt();" +
                    "\r\n\t\t\t\r\n\t\t\tif(socketChannel.isOpen())\t\t\t\r\n\t\t\t\tsocketChannel.close();\t\r\n\t\t\t\r\n\t\t} c" +
                    "atch (IOException e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t\t\r\n\t\t//Raise IDisconnect" +
                    "ionHandlers\r\n\t\tfor (DisconnectionHandler disConnectionHandler : onDisconnect)\r\n\t" +
                    "\t\tdisConnectionHandler.onDisconnect();\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Uncompress if neede" +
                    "d and initialize internal buffer at the start of data \r\n\t * @param compressed tr" +
                    "ue if packet use compression \r\n\t */\r\n\tprotected void beginReadPacket(boolean com" +
                    "pressed){\r\n\t\tif(compressed && receiveBuffer.position() > 8){\r\n\t\t\tbyte[] compress" +
                    "edData = new byte[receiveBuffer.position() - 8];\r\n\t\t\treceiveBuffer.position(8);\t" +
                    "\t\t\r\n\t\t\treceiveBuffer.get(compressedData);\r\n\t\t\t\r\n\t\t\tbyte[] uncompressedData = new" +
                    " byte[4096];\r\n\t\t\tint size = CLZF.decompress(compressedData, compressedData.lengt" +
                    "h, uncompressedData, uncompressedData.length);\r\n\t\t\t\r\n\t\t\treceiveBuffer.position(8" +
                    ");\t\t\r\n\t\t\treceiveBuffer.put(uncompressedData, 0, size);\r\n\t\t}\t\t\t\t\t\t\r\n\t\t\r\n\t\treceive" +
                    "Buffer.flip();\r\n\t\treceiveBuffer.position(8); // set buffer position and the data" +
                    " beginning\r\n\t}\r\n\t\r\n    protected abstract void onReceive(int key);\r\n    \r\n    /*" +
                    "*\r\n     * Reads a byte from the current position\r\n     * @return The byte value " +
                    " \r\n     */\r\n    protected byte packetReadSByte(){\r\n\t\treturn receiveBuffer.get();" +
                    "\r\n\t}\r\n    \r\n    /**\r\n     * Reads a byte from the current position\r\n     * @retu" +
                    "rn The byte value \r\n     */\r\n    protected byte packetReadByte(){\r\n\t\treturn rece" +
                    "iveBuffer.get();\r\n\t}\r\n    \r\n    /**\r\n     * Reads a short (16-bits) from the cur" +
                    "rent position\r\n     * @return The short value \r\n     */\r\n    protected short pac" +
                    "ketReadInt16(){\r\n\t\treturn receiveBuffer.getShort();\r\n\t}\r\n    \r\n    /**\r\n     * R" +
                    "eads a short (16-bits) from the current position\r\n     * @return The short value" +
                    "\r\n     */\r\n    protected short packetReadUInt16(){\r\n\t\treturn receiveBuffer.getSh" +
                    "ort();\r\n\t}\r\n    \r\n    /**\r\n     * Reads an int (32-bits) from the current positi" +
                    "on\r\n     * @return The int value \r\n     */    \r\n    protected int packetReadInt3" +
                    "2(){\r\n\t\treturn receiveBuffer.getInt();\r\n\t}\r\n\t\r\n    /**\r\n     * Reads an int (32-" +
                    "bits) from the current position\r\n     * @return The int value  \r\n     */    \r\n  " +
                    "  protected int packetReadUInt32(){\r\n\t\treturn receiveBuffer.getInt();\r\n\t}\r\n    \r" +
                    "\n    /**\r\n     * Reads an long (64-bits) from the current position\r\n     * @retu" +
                    "rn The long value \r\n     */\r\n    protected long packetReadInt64(){\r\n\t\treturn rec" +
                    "eiveBuffer.getLong();\r\n\t}\r\n\t\r\n    /**\r\n     * Reads an long (64-bits) from the c" +
                    "urrent position\r\n     * @return The long value \r\n     */\r\n    protected long pac" +
                    "ketReadUInt64(){\r\n\t\treturn receiveBuffer.getLong();\r\n\t}\r\n    \r\n    /**\r\n     * R" +
                    "eads an boolean (8-bits) from the current position\r\n     * @return The boolean v" +
                    "alue \r\n     */\r\n    protected boolean packetReadBoolean(){\r\n\t\treturn receiveBuff" +
                    "er.get() != 0;\r\n\t}\r\n    \r\n    /**\r\n     * Reads an IEEE 754 single-precision (32" +
                    "-bits) floating-point number from the current position\r\n     * @return The float" +
                    " value\r\n     */\r\n    protected float packetReadSingle(){\r\n\t\treturn receiveBuffer" +
                    ".getFloat();\r\n\t}\r\n    \r\n    /**\r\n     * Reads an IEEE 754 double-precision (64-b" +
                    "its) floating-point number from the current position\r\n     * @return The double " +
                    "value\r\n     */\r\n    protected double packetReadDouble(){\r\n\t\treturn receiveBuffer" +
                    ".getDouble();\r\n\t}\r\n    \r\n    /**\r\n     * Reads an Date from the current position" +
                    "\r\n     * @return The Date value\r\n     */\r\n    protected Date packetReadDateTime(" +
                    "){\r\n    \t//make protocol better\r\n    \tshort year = receiveBuffer.getShort();\r\n  " +
                    "  \tshort month = receiveBuffer.getShort();\r\n    \tshort day = receiveBuffer.getSh" +
                    "ort();\r\n    \tshort hour = receiveBuffer.getShort();\r\n    \tshort minute = receive" +
                    "Buffer.getShort();\r\n    \tshort seconds = receiveBuffer.getShort();\r\n    \tshort m" +
                    "iliseconds = receiveBuffer.getShort();\r\n    \t\r\n    \tGregorianCalendar calendar =" +
                    " new GregorianCalendar();\r\n    \tcalendar.set(year,month,day,hour,minute,seconds)" +
                    ";\r\n    \tlong totalMilisec = calendar.getTimeInMillis();\r\n    \ttotalMilisec += mi" +
                    "liseconds;\r\n\t\t\r\n    \treturn new Date(totalMilisec);\r\n\t}\r\n    \r\n    /**\r\n     * R" +
                    "eads a String from the buffer\r\n     * @return The String value at the current po" +
                    "sition \r\n     */    \r\n    protected String packetReadString(){\r\n\t\tint size = rec" +
                    "eiveBuffer.getInt();\r\n\t\tif(size > 0){\r\n\t\t\ttry {\r\n\t\t\t\tbyte[] bytes = new byte[siz" +
                    "e];\r\n\t\t\t\treceiveBuffer.get(bytes);\r\n\t\t\t\treturn new String(bytes,\"UTF-8\");\r\n\t\t\t} " +
                    "catch (UnsupportedEncodingException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t" +
                    "\treturn \"\";\r\n\t}\r\n    \r\n    /**\r\n     * Reads an array of byte from the current p" +
                    "osition\r\n     * @return The byte[] value\r\n     */\r\n    protected byte[] packetRe" +
                    "adListOfByte(){\r\n    \tint size = receiveBuffer.getInt();\r\n    \tif(size > 0){\r\n  " +
                    "  \t\tbyte[] bytes = new byte[size];\r\n\t\t\treceiveBuffer.get(bytes);\r\n\t\t\treturn byte" +
                    "s;\r\n    \t}\r\n    \treturn null;\r\n    }\r\n\r\n    /**\r\n     * Reads an array of short " +
                    "from the current position\r\n     * @return The short[] value\r\n     */\r\n    protec" +
                    "ted short[] packetReadListOfInt16(){\r\n    \tint size = receiveBuffer.getInt();\r\n " +
                    "   \tif(size > 0){\r\n    \t\tshort[] shorts = new short[size];\r\n    \t\tfor(int index " +
                    "= 0; index < size; index++){\r\n    \t\t\tshorts[index] = receiveBuffer.getShort();\r\n" +
                    "    \t\t}    \t\t\r\n    \t\treturn shorts;\r\n    \t}\r\n    \treturn null;\r\n    }\r\n    \r\n   " +
                    " /**\r\n     * Reads an array of short from the current position\r\n     * @return T" +
                    "he short[] value \r\n     */\r\n    protected short[] packetReadListOfUInt16(){\r\n   " +
                    " \tint size = receiveBuffer.getInt();\r\n    \tif(size > 0){\r\n    \t\tshort[] shorts =" +
                    " new short[size];\r\n    \t\tfor(int index = 0; index < size; index++){\r\n    \t\t\tshor" +
                    "ts[index] = receiveBuffer.getShort();\r\n    \t\t}    \t\t\r\n    \t\treturn shorts;\r\n    " +
                    "\t}\r\n    \treturn null;\r\n    }\r\n    \r\n    /**\r\n     * Reads an array of int from t" +
                    "he current position\r\n     * @return The int[] value \r\n     */\r\n    protected int" +
                    "[] packetReadListOfInt32(){\r\n    \tint size = receiveBuffer.getInt();\r\n    \tif(si" +
                    "ze > 0){\r\n    \t\tint[] ints = new int[size];\r\n    \t\tfor(int index = 0; index < si" +
                    "ze; index++){\r\n    \t\t\tints[index] = receiveBuffer.getInt();\r\n    \t\t}    \t\t\r\n    " +
                    "\t\treturn ints;\r\n    \t}\r\n    \treturn null;\r\n    }\r\n    \r\n    /**\r\n     * Reads an" +
                    " array of int from the current position\r\n     * @return The int[] value\r\n     */" +
                    "\r\n    protected int[] packetReadListOfUInt32(){\r\n    \tint size = receiveBuffer.g" +
                    "etInt();\r\n    \tif(size > 0){\r\n    \t\tint[] ints = new int[size];\r\n    \t\tfor(int i" +
                    "ndex = 0; index < size; index++){\r\n    \t\t\tints[index] = receiveBuffer.getInt();\r" +
                    "\n    \t\t}    \t\t\r\n    \t\treturn ints;\r\n    \t}\r\n    \treturn null;\r\n    }\r\n    \r\n    " +
                    "/**\r\n     * Reads an array of long from the current position\r\n     * @return The" +
                    " long[] value\r\n     */\r\n    protected long[] packetReadListOfInt64(){\r\n    \tint " +
                    "size = receiveBuffer.getInt();\r\n    \tif(size > 0){\r\n    \t\tlong[] longs = new lon" +
                    "g[size];\r\n    \t\tfor(int index = 0; index < size; index++){\r\n    \t\t\tlongs[index] " +
                    "= receiveBuffer.getLong();\r\n    \t\t}    \t\t\r\n    \t\treturn longs;\r\n    \t}\r\n    \tret" +
                    "urn null;\r\n    }\r\n    \r\n    /**\r\n     * Reads an array of long from the current " +
                    "position\r\n     * @return The long[] value\r\n     */\r\n    protected long[] packetR" +
                    "eadListOfUInt64(){\r\n    \tint size = receiveBuffer.getInt();\r\n    \tif(size > 0){\r" +
                    "\n    \t\tlong[] longs = new long[size];\r\n    \t\tfor(int index = 0; index < size; in" +
                    "dex++){\r\n    \t\t\tlongs[index] = receiveBuffer.getLong();\r\n    \t\t}    \t\t\r\n    \t\tre" +
                    "turn longs;\r\n    \t}\r\n    \treturn null;\r\n    }\r\n    \r\n    /**\r\n     * Reads an ar" +
                    "ray of boolean from the current position\r\n     * @return The boolean[] value\r\n  " +
                    "   */\r\n    protected boolean[] packetReadListOfBoolean(){\r\n    \tint size = recei" +
                    "veBuffer.getInt();\r\n    \tif(size > 0){\r\n    \t\tboolean[] booleans = new boolean[s" +
                    "ize];\r\n    \t\tfor(int index = 0; index < size; index++){\r\n    \t\t\tbooleans[index] " +
                    "= receiveBuffer.get() != 0;\r\n    \t\t}    \t\t\r\n    \t\treturn booleans;\r\n    \t}\r\n    " +
                    "\treturn null;\r\n    }\r\n    \r\n    /**\r\n     * Reads an array of float from the cur" +
                    "rent position\r\n     * @return The float[] value \r\n     */\r\n    protected float[]" +
                    " packetReadListOfSingle(){\r\n    \tint size = receiveBuffer.getInt();\r\n    \tif(siz" +
                    "e > 0){\r\n    \t\tfloat[] floats = new float[size];\r\n    \t\tfor(int index = 0; index" +
                    " < size; index++){\r\n    \t\t\tfloats[index] = receiveBuffer.getFloat();\r\n    \t\t}   " +
                    " \t\t\r\n    \t\treturn floats;\r\n    \t}\r\n    \treturn null;\r\n    }\r\n    \r\n    /**\r\n    " +
                    " * Reads an array of double from the current position\r\n     * @return The double" +
                    "[] value\r\n     */\r\n    protected double[] packetReadListOfDouble(){\r\n    \tint si" +
                    "ze = receiveBuffer.getInt();\r\n    \tif(size > 0){\r\n    \t\tdouble[] doubles = new d" +
                    "ouble[size];\r\n    \t\tfor(int index = 0; index < size; index++){\r\n    \t\t\tdoubles[i" +
                    "ndex] = receiveBuffer.getDouble();\r\n    \t\t}    \t\t\r\n    \t\treturn doubles;\r\n    \t}" +
                    "\r\n    \treturn null;\r\n    }\r\n    \r\n    /**\r\n     * Reads an array of Date from th" +
                    "e current position\r\n     * @return The Date[] value \r\n     */\r\n    protected Dat" +
                    "e[] packetReadListOfDateTime(){\r\n    \tint size = receiveBuffer.getInt();\r\n    \ti" +
                    "f(size > 0){\r\n    \t\tDate[] dates = new Date[size];\r\n    \t\tfor(int index = 0; ind" +
                    "ex < size; index++){\r\n    \t\t\tdates[index] = packetReadDateTime();\r\n    \t\t}    \t\t" +
                    "\r\n    \t\treturn dates;\r\n    \t}\r\n    \treturn null;\r\n    }\r\n    \r\n    /**\r\n     * R" +
                    "eads an array of String from the current position\r\n     * @return The String[] v" +
                    "alue\r\n     */    \r\n    protected String[] packetReadListOfString(){\r\n    \tint si" +
                    "ze = receiveBuffer.getInt();\r\n    \tif(size > 0){\r\n    \t\tString[] strings = new S" +
                    "tring[size];\r\n    \t\tfor(int index = 0; index < size; index++){\r\n    \t\t\tstrings[i" +
                    "ndex] = packetReadString();\r\n    \t\t}    \t\t\r\n    \t\treturn strings;\r\n    \t}\r\n    \t" +
                    "return null;\r\n    }\r\n    \r\n    \r\n\t\r\n\t//Write packets\t\r\n    /**\r\n     * Begin a n" +
                    "ew packet to write\r\n     * @param key Packet key \r\n     */\r\n\tprotected void begi" +
                    "nNewPacket(int key){\r\n\t\tsendBuffer.clear();\r\n\t\tsendBuffer.position(4); //Skip si" +
                    "ze\r\n\t\tsendBuffer.putInt(key);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write a byte to the buffer at th" +
                    "e current position \r\n\t * @param value The byte value to write\r\n\t */\r\n\tprotected " +
                    "void packetWrite(byte value){\r\n\t\tsendBuffer.put(value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write " +
                    "a short to the buffer at the current position \r\n\t * @param value The short value" +
                    " to write\r\n\t */\t\r\n\tprotected void packetWrite(short value){\r\n\t\tsendBuffer.putSho" +
                    "rt(value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write a int to the buffer at the current position \r" +
                    "\n\t * @param value The int value to write\r\n\t */\t\r\n\tprotected void packetWrite(int" +
                    " value){\r\n\t\tsendBuffer.putInt(value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write a long to the buff" +
                    "er at the current position \r\n\t * @param value The long value to write\r\n\t */\t\r\n\tp" +
                    "rotected void packetWrite(long value){\r\n\t\tsendBuffer.putLong(value);\r\n\t}\r\n\t\r\n\t/*" +
                    "*\r\n\t * Write a float to the buffer at the current position \r\n\t * @param value Th" +
                    "e float value to write\r\n\t */\t\r\n\tprotected void packetWrite(float value){\r\n\t\tsend" +
                    "Buffer.putFloat(value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write a double to the buffer at the cu" +
                    "rrent position \r\n\t * @param value The double value to write\r\n\t */\t\r\n\tprotected v" +
                    "oid packetWrite(double value){\r\n\t\tsendBuffer.putDouble(value);\r\n\t}\r\n\t\r\n\t/**\r\n\t *" +
                    " Write a boolean to the buffer at the current position \r\n\t * @param value the bo" +
                    "olean value to write\r\n\t */\r\n\tprotected void packetWrite(boolean value){\r\n\t\tif(va" +
                    "lue)\r\n\t\t\tsendBuffer.put((byte)1);\t\r\n\t\telse\r\n\t\t\tsendBuffer.put((byte)0);\r\n\t}\r\n\r\n\t" +
                    "/**\r\n\t * Write a String to the buffer at the current position \r\n\t * @param value" +
                    " The String value to write\r\n\t */\t\r\n\tprotected void packetWrite(Date value){\t\r\n\t\t" +
                    "GregorianCalendar calendar = new GregorianCalendar();\r\n\t\tcalendar.setTime(value)" +
                    ";\r\n\t\tsendBuffer.putInt((short)calendar.get(GregorianCalendar.YEAR));\r\n\t\tsendBuff" +
                    "er.putInt((short)calendar.get(GregorianCalendar.MONTH));\r\n\t\tsendBuffer.putInt((s" +
                    "hort)calendar.get(GregorianCalendar.DAY_OF_MONTH));\r\n\t\tsendBuffer.putInt((short)" +
                    "calendar.get(GregorianCalendar.HOUR_OF_DAY));\r\n\t\tsendBuffer.putInt((short)calend" +
                    "ar.get(GregorianCalendar.MINUTE));\r\n\t\tsendBuffer.putInt((short)calendar.get(Greg" +
                    "orianCalendar.SECOND));\r\n\t\tsendBuffer.putInt((short)calendar.get(GregorianCalend" +
                    "ar.MILLISECOND));\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write a String to the buffer at the curren" +
                    "t position \r\n\t * @param value The String value to write\r\n\t */\t\r\n\tprotected void " +
                    "packetWrite(String value){\t\t\r\n\t\ttry {\r\n\t\t\tpacketWrite(value.getBytes(\"UTF-8\"));\r" +
                    "\n\t\t} catch (UnsupportedEncodingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\t" +
                    "\r\n\t\t\r\n\t/**\r\n\t * Write an array of byte to the buffer at the current position \r\n\t" +
                    " * @param value The byte[] value to write\r\n\t */\r\n\tprotected void packetWrite(byt" +
                    "e[] value){\r\n\t\tsendBuffer.putInt(value.length);\r\n\t\tsendBuffer.put(value);\r\n\t}\r\n\t" +
                    "\r\n\t/**\r\n\t * Write an array of short to the buffer at the current position \r\n\t * " +
                    "@param value The short[] value to write\r\n\t */\r\n\tprotected void packetWrite(short" +
                    "[] value){\r\n\t\tsendBuffer.putInt(value.length);\r\n\t\tfor (short element : value)\t\t\t" +
                    "\r\n\t\t\tpacketWrite(element);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write an array of int to the buffer" +
                    " at the current position \r\n\t * @param value The int[] value to write\r\n\t */\r\n\tpro" +
                    "tected void packetWrite(int[] value){\r\n\t\tsendBuffer.putInt(value.length);\r\n\t\tfor" +
                    " (int element : value)\t\t\t\r\n\t\t\tpacketWrite(element);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write an a" +
                    "rray of long to the buffer at the current position \r\n\t * @param value The long[]" +
                    " value to write\r\n\t */\r\n\tprotected void packetWrite(long[] value){\r\n\t\tsendBuffer." +
                    "putInt(value.length);\r\n\t\tfor (long element : value)\t\t\t\r\n\t\t\tpacketWrite(element);" +
                    "\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write an array of float to the buffer at the current position" +
                    " \r\n\t * @param value The float[] value to write\r\n\t */\r\n\tprotected void packetWrit" +
                    "e(float[] value){\r\n\t\tsendBuffer.putInt(value.length);\r\n\t\tfor (float element : va" +
                    "lue)\t\t\t\r\n\t\t\tpacketWrite(element);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Write an array of double to " +
                    "the buffer at the current position \r\n\t * @param value The double[] value to writ" +
                    "e\r\n\t */\r\n\tprotected void packetWrite(double[] value){\r\n\t\tsendBuffer.putInt(value" +
                    ".length);\r\n\t\tfor (double element : value)\t\t\t\r\n\t\t\tpacketWrite(element);\r\n\t}\r\n\t\r\n\t" +
                    "/**\r\n\t * Write an array of double to the buffer at the current position \r\n\t * @p" +
                    "aram value The boolean[] value to write\r\n\t */\r\n\tprotected void packetWrite(boole" +
                    "an[] value){\r\n\t\tsendBuffer.putInt(value.length);\r\n\t\tfor (boolean element : value" +
                    ")\t\t\t\r\n\t\t\tpacketWrite(element);\r\n\t}\r\n\r\n\t/**\r\n\t * Write an array of String to the " +
                    "buffer at the current position \r\n\t * @param value The String[] value to write\r\n\t" +
                    " */\r\n\tprotected void packetWrite(String[] value){\r\n\t\tsendBuffer.putInt(value.len" +
                    "gth);\r\n\t\tfor (String element : value)\t\t\t\r\n\t\t\tpacketWrite(element);\r\n\t}\r\n\t\r\n\t/**\r" +
                    "\n\t * Write an array of Date to the buffer at the current position \r\n\t * @param v" +
                    "alue The Date[] value to write\r\n\t */\r\n\tprotected void packetWrite(Date[] value){" +
                    "\r\n\t\tsendBuffer.putInt(value.length);\r\n\t\tfor (Date element : value)\t\t\t\r\n\t\t\tpacket" +
                    "Write(element);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Send the packet\r\n\t * @param compressed True if" +
                    " compression must be use\r\n \t */\r\n\tprotected void sendPacket(boolean compressed){" +
                    "\r\n\t\ttry {\t\t\t\r\n\t\t\tif(compressed && sendBuffer.position() > 8){\t\t\r\n\t\t\t\tbyte[] unco" +
                    "mpressedData = new byte[sendBuffer.position() - 8];\r\n\t\t\t\tsendBuffer.position(8);" +
                    "\t\t\t\r\n\t\t\t\tsendBuffer.get(uncompressedData);\r\n\t\t\t\t\r\n\t\t\t\tbyte[] compressedData = ne" +
                    "w byte[4096];\r\n\t\t\t\tint size = CLZF.compress(uncompressedData, uncompressedData.l" +
                    "ength, compressedData, compressedData.length);\r\n\t\t\t\t\r\n\t\t\t\tsendBuffer.position(8)" +
                    ";\t\t\r\n\t\t\t\tsendBuffer.put(compressedData, 0, size);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsendBuffer.flip" +
                    "();\t\r\n\t\t\t\r\n\t\t\tsendBuffer.putInt(0, sendBuffer.remaining() - 4); //Set the Size (" +
                    "Don\'t count the size himself)\t\t\t\t\t\t\r\n\t\t\twhile(sendBuffer.hasRemaining()) {\t\t\t\t\r\n" +
                    "\t\t\t\t\tsocketChannel.write(sendBuffer);\t\t\t\t\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t" +
                    "\tdisconnect();\r\n\t\t\tthrow new IOError(e); //make catch optional\t\t\r\n\t\t}\r\n\t}\r\n\r\n\t@D" +
                    "eprecated\r\n    protected Object packetReadDynamic()\r\n    {\r\n        if (packetRe" +
                    "adBoolean())\r\n        {\r\n            switch (packetReadString())\r\n            {\r" +
                    "\n                case \"Byte\":\r\n                    return packetReadByte();\r\n   " +
                    "             case \"UInt16\":\r\n                    return packetReadUInt16();\r\n   " +
                    "             case \"Int16\":\r\n                    return packetReadInt16();\r\n     " +
                    "           case \"UInt32\":\r\n                    return packetReadUInt32();\r\n     " +
                    "           case \"Int32\":\r\n                    return packetReadInt32();\r\n       " +
                    "         case \"UInt64\":\r\n                    return packetReadUInt64();\r\n       " +
                    "         case \"Int64\":\r\n                    return packetReadInt64();\r\n         " +
                    "       case \"Single\":\r\n                    return packetReadSingle();\r\n         " +
                    "       case \"Double\":\r\n                    return packetReadDouble();\r\n         " +
                    "       case \"Boolean\":\r\n                    return packetReadBoolean();\r\n       " +
                    "         case \"String\":\r\n                    return packetReadString();\r\n       " +
                    "         case \"DateTime\":\r\n                    return packetReadDateTime();\r\n   " +
                    "         }\r\n        }\r\n        return null;\r\n    }\r\n\t\r\n\t@Deprecated\r\n\tprotected " +
                    "void packetWriteDynamic(Object value){\r\n\t\tif (value instanceof Byte)\r\n        {\r" +
                    "\n            packetWrite(true);\r\n            packetWrite(\"Byte\");\r\n            p" +
                    "acketWrite((byte)value);\r\n        }\r\n        else if (value instanceof Short)\r\n " +
                    "       {\r\n            packetWrite(true);\r\n            packetWrite(\"Int16\");\r\n   " +
                    "         packetWrite((short)value);\r\n        }\r\n        else if (value instanceo" +
                    "f Integer)\r\n        {\r\n        \tpacketWrite(true);\r\n        \tpacketWrite(\"Int32\"" +
                    ");\r\n        \tpacketWrite((int)value);\r\n        }\r\n        else if (value instanc" +
                    "eof Long)\r\n        {\r\n        \tpacketWrite(true);\r\n        \tpacketWrite(\"Int64\")" +
                    ";\r\n        \tpacketWrite((long)value);\r\n        }\r\n        else if (value instanc" +
                    "eof Float)\r\n        {\r\n        \tpacketWrite(true);\r\n            packetWrite(\"Sin" +
                    "gle\");\r\n            packetWrite((float)value);\r\n        }\r\n        else if (valu" +
                    "e instanceof Double)\r\n        {\r\n            packetWrite(true);\r\n            pac" +
                    "ketWrite(\"Double\");\r\n            packetWrite((double)value);\r\n        }\r\n       " +
                    " else if (value instanceof Boolean)\r\n        {\r\n            packetWrite(true);\r\n" +
                    "            packetWrite(\"Boolean\");\r\n            packetWrite((boolean)value);\r\n " +
                    "       }\r\n        else if (value instanceof String)\r\n        {\r\n            pack" +
                    "etWrite(true);\r\n            packetWrite(\"String\");\r\n            packetWrite((Str" +
                    "ing)value);\r\n        }\r\n        else if (value instanceof Date)\r\n        {\r\n    " +
                    "        packetWrite(true);\r\n            packetWrite(\"DateTime\");\r\n            pa" +
                    "cketWrite((Date)value);\r\n        }\r\n        else\r\n            packetWrite(false)" +
                    ";\r\n\t}\r\n\t\r\n\t@Deprecated\r\n\tprotected Object[] packetReadListOfDynamic(){\r\n    \tint" +
                    " size = receiveBuffer.getInt();\r\n    \tif(size > 0){\r\n    \t\tObject[] objects = ne" +
                    "w Object[size];\r\n    \t\tfor(int index = 0; index < size; index++){\r\n    \t\t\tobject" +
                    "s[index] = packetReadDynamic();\r\n    \t\t}    \t\t\r\n    \t\treturn objects;\r\n    \t}\r\n " +
                    "   \treturn null;\r\n    }      \r\n\t\r\n\t@Deprecated\r\n    protected void packetWriteDy" +
                    "namic(Object[] value)\r\n    {\r\n\t\tsendBuffer.putInt(value.length);\r\n\t\tfor (Object " +
                    "element : value)\t\t\t\r\n\t\t\tpacketWriteDynamic(element);\r\n    }\r\n\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public class AbstractTcpChannelTemplateBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
