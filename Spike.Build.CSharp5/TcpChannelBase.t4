  /// <summary>
    /// Represents a connection result.
    /// </summary>
    public enum ConnectionResult
    {
        /// <summary>
        /// Represents that the connection was established.
        /// </summary>
        Connected,

        /// <summary>
        /// Repreesnts an error.
        /// </summary>
        Error
    }

    /// <summary>
    /// Represents a connection error.
    /// </summary>
    public enum ConnectionError
    {
        /// <summary>
        /// Unknown connection error has occured.
        /// </summary>
        Unknown,

        /// <summary>
        /// Represents a manual disconnection error.
        /// </summary>
        Manual,

        /// <summary>
        /// Represents a connection error during a connect.
        /// </summary>
        Connection,

        /// <summary>
        /// Represents a connection error during the receive.
        /// </summary>
        Receive,

        /// <summary>
        /// Represents a connection error during the send.
        /// </summary>
        Send
    }

    /// <summary>
    /// Represents a TCP Channel.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class TcpChannelBase<T> where T : TcpChannelBase<T>
    {
        private Socket TcpSocket;
        private Stream InnerStream;
        private object Lock = new object();
        private byte[] ReceiveBuffer;
        private int ReceiveBufferPosition;
        private int ReceiveBufferSize;

        /// <summary>
        /// An event that occurs when the channel is connected to the remote endpoint.
        /// </summary>
        public event Action<T> Connected;

        /// <summary>
        /// An event that occurs when the channel is disconnected to the remote endpoint.
        /// </summary>
        public event Action<T,ConnectionError> Disconnected;

        /// <summary>
        /// Constructs a new instance of a channel.
        /// </summary>
        /// <param name="bufferCapacity">The buffer capacity to allocate.</param>
        /// <param name="tls">Whether SSL/TLS should be used or not.</param>
        public TcpChannelBase(int bufferCapacity, bool tls)
        {
            this.BufferCapacity = bufferCapacity;
            this.TlsSecure = tls;
        }

        /// <summary>
        /// Gets the max capacity buffer size.
        /// </summary>
        public int BufferCapacity 
        {
            get;
            protected set; 
        }

        /// <summary>
        /// Whether this channel is secured with TLS/SSL.
        /// </summary>
        public bool TlsSecure
        {
            get;
            protected set;
        }

        /// <summary>
        /// This packet writer is used to serialize packets. We need to maintain
        /// the state for each thread, hence this is thread static.
        /// </summary>
        [ThreadStatic]
        private static PacketWriter PacketWriter;

        /// <summary>
        /// Gets a packet writer for the current thread.
        /// </summary>
        public PacketWriter Writer
        {
            get 
            {
                if (PacketWriter == null)
                    PacketWriter = new PacketWriter(this.BufferCapacity);
                return PacketWriter;
            }
        }


        /// <summary>
        /// Gets whether the current channel is connected or not.
        /// </summary>
        public bool IsConnected 
        {

            get 
            {
                return (TcpSocket != null && TcpSocket.Connected);
            }
        }

        /// <summary>
        /// Connects to the specified hostname and port and start listening to it.
        /// </summary>
        /// <param name="host">The host to connect to.</param>
        /// <param name="port">The port to connect to.</param>
        /// <returns>The result of the connection.</returns>
        public async Task<ConnectionResult> Connect(string host, int port)
        {
            try
            {
                TcpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                await Task.Factory.FromAsync(
                TcpSocket.BeginConnect, 
                TcpSocket.EndConnect,
                host, port, null);

                if (TlsSecure)
                {
                    var sslStream = new SslStream(new NetworkStream(TcpSocket),
                    false,
                    (sender, certificate, chain, sslPolicyErrors) => 
                    {
                        return true; 
                    }
                    //Accept self signed
                    );
                    sslStream.AuthenticateAsClient("Spike Client");
                    InnerStream = sslStream;
                }
                else
                InnerStream = new NetworkStream(TcpSocket);


                ReceiveBuffer = new byte[BufferCapacity];
                ReceiveBufferPosition = 0;
                ReceiveBufferSize = 0;

                if (Connected != null)
                Connected((T)this);

                ReceiveLoop();

                return ConnectionResult.Connected;
            }
            catch (Exception)
            {
                return ConnectionResult.Error;
            }
        }

        /// <summary>
        /// Disconnects the channel from the remote endpoint.
        /// </summary>
        public void Disconnect()
        {
            Disconnect(ConnectionError.Manual);
        }

        #region Receive Members
        protected abstract void OnReceive(uint key);

        private async void ReceiveLoop()
        {
            while (true)
            {
                //Read Size
                ReceiveBufferPosition = 0;
                ReceiveBufferSize = await Task.Run(() => Fill(sizeof(int)));
                if (ReceiveBufferSize != sizeof(int))
                {
                    Disconnect(ConnectionError.Receive);
                    return;
                }

                //read packet data
                ReceiveBufferPosition = 0;
                ReceiveBufferSize = PacketReadInt32() + sizeof(int);

                do
                {
                    var readed = await Task.Run(() => Fill(ReceiveBufferSize - ReceiveBufferPosition));
                    if (readed == 0)
                    {
                        Disconnect(ConnectionError.Receive);
                        return;
                    }
                    ReceiveBufferPosition += readed;
                } while (ReceiveBufferPosition < ReceiveBufferSize);

                ReceiveBufferPosition = sizeof(int);

                OnReceive(PacketReadUInt32());
            }
        }

        #endregion

        #region Private/Protected Members

        private int Fill(int size)
        {

            try
            {
                return InnerStream.Read(ReceiveBuffer, ReceiveBufferPosition, size);
                //return socket.Receive(ReceiveBuffer,ReceiveBufferPosition,size,SocketFlags.None);
            }
            catch (Exception)
            {
                return 0;
            }
        }


        private void Disconnect(ConnectionError error)
        {
            var mustRaise = false;
            lock (Lock)
            {
                if (TcpSocket != null)
                {
                    TcpSocket.Dispose();
                    mustRaise = true;
                    TcpSocket = null;
                }
            }

            if (mustRaise)
            Disconnected((T)this, error);            
        }

        protected void BeginReadPacket(bool compressed)
        {
            if (compressed)
            {
                var compressedBuffer = new byte[ReceiveBufferSize - 8];
                var uncompressedBuffer = new byte[BufferCapacity];
                Buffer.BlockCopy(ReceiveBuffer, 8, compressedBuffer, 0, compressedBuffer.Length);
                var cipher = new CLZF();
                var uncompressedSize = cipher.lzf_decompress(compressedBuffer, compressedBuffer.Length, uncompressedBuffer, uncompressedBuffer.Length);
                Buffer.BlockCopy(uncompressedBuffer, 0, ReceiveBuffer, 8, uncompressedSize);
                ReceiveBufferSize = uncompressedSize + 8;
            }
        }


        protected async Task SendPacket(PacketWriter writer, bool compressed)
        {
            try
            {
                // Get the final buffer we should send
                var buffer = writer.Flush(compressed);
                var success = await Task.Run<bool>(() => 
                {
                    try 
                    {
                        InnerStream.Write(buffer, 0, buffer.Length);
                        return true;
                    }
                    catch(Exception)
                    {
                        return false;
                    }
                });

                if(!success)
                {
                    Disconnect(ConnectionError.Send);
                    return;
                }
            }
            catch (Exception)
            {
                Disconnect(ConnectionError.Unknown);
            }
        }

        #endregion

        #region Packet Read

        protected byte PacketReadByte()
        {
            return ReceiveBuffer[ReceiveBufferPosition++];
        }
        protected byte[] PacketReadListOfByte()
        {
            var value = new byte[PacketReadInt32()];
            Buffer.BlockCopy(ReceiveBuffer, ReceiveBufferPosition, value, 0, value.Length);
            ReceiveBufferPosition += value.Length;
            return value;
        }

        // UInt16
        protected ushort PacketReadUInt16()
        {
            return (ushort)((ReceiveBuffer[ReceiveBufferPosition++] << 8)
            | ReceiveBuffer[ReceiveBufferPosition++]);
        }

        protected ushort[] PacketReadListOfUInt16()
        {
            var value = new ushort[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadUInt16();
            return value;
        }

        // Int16
        protected short PacketReadInt16()
        {
            return (short)((ReceiveBuffer[ReceiveBufferPosition++] << 8)
            | ReceiveBuffer[ReceiveBufferPosition++]);
        }

        protected short[] PacketReadListOfInt16()
        {
            var value = new short[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadInt16();
            return value;
        }
 
        // UInt32
        protected uint PacketReadUInt32()
        {
            return (uint)(ReceiveBuffer[ReceiveBufferPosition++] << 24
            | (ReceiveBuffer[ReceiveBufferPosition++] << 16)
            | (ReceiveBuffer[ReceiveBufferPosition++] << 8)
            | (ReceiveBuffer[ReceiveBufferPosition++]));
        }

        protected uint[] PacketReadListOfUInt32()
        {
            var value = new uint[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadUInt32();
            return value;
        }
 
        // Int32
        protected int PacketReadInt32()
        {
            return ReceiveBuffer[ReceiveBufferPosition++] << 24
            | (ReceiveBuffer[ReceiveBufferPosition++] << 16)
            | (ReceiveBuffer[ReceiveBufferPosition++] << 8)
            | (ReceiveBuffer[ReceiveBufferPosition++]);
        }

        protected int[] PacketReadListOfInt32()
        {
            var value = new int[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadInt32();
            return value;
        }

        // UInt64
        protected ulong PacketReadUInt64()
        {
            ulong value = ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++];
            return value;
        }

        protected ulong[] PacketReadListOfUInt64()
        {
            var value = new ulong[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadUInt64();
            return value;
        }

        // Int64
        protected long PacketReadInt64()
        {
            long value = ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++]; value <<= 8;
            value |= ReceiveBuffer[ReceiveBufferPosition++];
            return value;
        }

        protected long[] PacketReadListOfInt64()
        {
            var value = new long[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadInt64();
            return value;
        }

        // Boolean
        protected bool PacketReadBoolean()
        {
            return ReceiveBuffer[ReceiveBufferPosition++] != 0;
        }

        public bool[] PacketReadListOfBoolean()
        {
            var value = new bool[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadBoolean();
            return value;
        }

        protected float PacketReadSingle()
        {
            var bytes = new byte[sizeof(float)];
            for (var index = bytes.Length - 1; index >= 0; --index)
            bytes[index] = PacketReadByte();
            return BitConverter.ToSingle(bytes, 0); 
        }

        protected float[] PacketReadListOfSingle()
        {
            var value = new float[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadSingle();
            return value;
        }

        protected double PacketReadDouble()
        {
            var bytes = new byte[sizeof(double)];
            for (var index = bytes.Length - 1; index >= 0; --index)
            bytes[index] = PacketReadByte();
            return BitConverter.ToDouble(bytes, 0);
        }

        protected double[] PacketReadListOfDouble()
        {
            var value = new double[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadDouble();
            return value;
        }

        // String
        protected string PacketReadString()
        {
            var bytes = PacketReadListOfByte();
            return Encoding.UTF8.GetString(bytes, 0, bytes.Length);
        }

        protected string[] PacketReadListOfString()
        {
            var value = new string[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadString();
            return value;
        }
        // DateTime
        protected DateTime PacketReadDateTime()
        {
            var year = PacketReadInt16();
            var month = PacketReadInt16();
            var day = PacketReadInt16();
            var hour = PacketReadInt16();
            var minute = PacketReadInt16();
            var second = PacketReadInt16();
            var millisecond = PacketReadInt16();

            return new DateTime(year, month, day, hour, minute, second, millisecond);
        }

        protected DateTime[] PacketReadListOfDateTime()
        {
            var value = new DateTime[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadDateTime();
            return value;
        }

        [Obsolete("DynamicType is obsolete. Consider using JSON or XML serialized objects instead.", false)]
        protected object PacketReadDynamicType()
        {
            if (PacketReadBoolean())
            {
                switch (PacketReadString())
                {
                    case "Byte":
                    return PacketReadByte();
                    case "UInt16":
                    return PacketReadUInt16();
                    case "Int16":
                    return PacketReadInt16();
                    case "UInt32":
                    return PacketReadUInt32();
                    case "Int32":
                    return PacketReadInt32();
                    case "UInt64":
                    return PacketReadUInt64();
                    case "Int64":
                    return PacketReadInt64();
                    case "Single":
                    return PacketReadSingle();
                    case "Double":
                    return PacketReadDouble();
                    case "Boolean":
                    return PacketReadBoolean();
                    case "String":
                    return PacketReadString();
                    case "DateTime":
                    return PacketReadDateTime();
                }
            }
            return null;
        }

        [Obsolete("DynamicType is obsolete. Consider using JSON or XML serialized objects instead.", false)]
        protected object[] PacketReadListOfDynamicType()
        {
            var value = new object[PacketReadInt32()];
            for (int index = 0; index < value.Length; index++)
            value[index] = PacketReadDynamicType();
            return value;
        }
        #endregion
    }