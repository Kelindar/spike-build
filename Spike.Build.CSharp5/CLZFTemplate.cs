// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Spike.Build.CSharp5
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "C:\Users\Fabian\Desktop\Projects\GitHub\spike-build\Spike.Build.CSharp5\CLZFTemplate.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public partial class CLZFTemplate : CLZFTemplateBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("/*\r\n * Copyright (c) 2005 Oren J. Maurice <oymaurice@hazorea.org.il>\r\n * \r\n * Red" +
                    "istribution and use in source and binary forms, with or without modifica-\r\n * ti" +
                    "on, are permitted provided that the following conditions are met:\r\n * \r\n *   1. " +
                    " Redistributions of source code must retain the above copyright notice,\r\n *     " +
                    "  this list of conditions and the following disclaimer.\r\n * \r\n *   2.  Redistrib" +
                    "utions in binary form must reproduce the above copyright\r\n *       notice, this " +
                    "list of conditions and the following disclaimer in the\r\n *       documentation a" +
                    "nd/or other materials provided with the distribution.\r\n * \r\n *   3.  The name of" +
                    " the author may not be used to endorse or promote products\r\n *       derived fro" +
                    "m this software without specific prior written permission.\r\n * \r\n * THIS SOFTWAR" +
                    "E IS PROVIDED BY THE AUTHOR ``AS IS\'\' AND ANY EXPRESS OR IMPLIED\r\n * WARRANTIES," +
                    " INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\r\n * CHANTABILITY " +
                    "AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\r\n * EVENT SHALL THE " +
                    "AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\r\n * CIAL, EXEMPLARY," +
                    " OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUB" +
                    "STITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\r\n * OR BUSINESS INTERR" +
                    "UPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, " +
                    "STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\r\n * ERWISE) ARISING IN A" +
                    "NY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n * OF THE POSSIBILITY O" +
                    "F SUCH DAMAGE.\r\n *\r\n * Alternatively, the contents of this file may be used unde" +
                    "r the terms of\r\n * the GNU General Public License version 2 (the \"GPL\"), in whic" +
                    "h case the\r\n * provisions of the GPL are applicable instead of the above. If you" +
                    " wish to\r\n * allow the use of your version of this file only under the terms of " +
                    "the\r\n * GPL and not to allow others to use your version of this file under the\r\n" +
                    " * BSD license, indicate your decision by deleting the provisions above and\r\n * " +
                    "replace them with the notice and other provisions required by the GPL. If\r\n * yo" +
                    "u do not delete the provisions above, a recipient may use your version\r\n * of th" +
                    "is file under either the BSD or the GPL.\r\n */\r\n\r\nusing System;\r\n\r\nnamespace LZF." +
                    "NET\r\n{\r\n\t\r\n\t/// <summary>\r\n\t/// Summary description for CLZF.\r\n\t/// </summary>\r\n" +
                    "\tpublic class CLZF\r\n\t{\r\n\t\t// CRC32 data & function\r\n\t\tUInt32 []crc_32_tab = new " +
                    "UInt32[256]\r\n\t\t{\r\n\t\t\t0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419," +
                    "\r\n\t\t\t0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\r\n\t\t\t0xe0d5e91e," +
                    " 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\r\n\t\t\t0x90bf1d91, 0x1db71064, 0x6" +
                    "ab020f2, 0xf3b97148, 0x84be41de,\r\n\t\t\t0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d38" +
                    "5c7, 0x136c9856,\r\n\t\t\t0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9," +
                    "\r\n\t\t\t0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\r\n\t\t\t0xa2677172," +
                    " 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\r\n\t\t\t0x35b5a8fa, 0x42b2986c, 0xd" +
                    "bbbc9d6, 0xacbcf940, 0x32d86ce3,\r\n\t\t\t0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d93" +
                    "0ac, 0x51de003a,\r\n\t\t\t0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599," +
                    "\r\n\t\t\t0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\r\n\t\t\t0x2f6f7c87," +
                    " 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\r\n\t\t\t0x01db7106, 0x98d220bc, 0xe" +
                    "fd5102a, 0x71b18589, 0x06b6b51f,\r\n\t\t\t0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f" +
                    "934, 0x9609a88e,\r\n\t\t\t0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01," +
                    "\r\n\t\t\t0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\r\n\t\t\t0x1b01a57b," +
                    " 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\r\n\t\t\t0x8bbeb8ea, 0xfcb9887c, 0x6" +
                    "2dd1ddf, 0x15da2d49, 0x8cd37cf3,\r\n\t\t\t0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0" +
                    "074, 0xd4bb30e2,\r\n\t\t\t0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a," +
                    "\r\n\t\t\t0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\r\n\t\t\t0xaa0a4c5f," +
                    " 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\r\n\t\t\t0xc90c2086, 0x5768b525, 0x2" +
                    "06f85b3, 0xb966d409, 0xce61e49f,\r\n\t\t\t0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a" +
                    "8b4, 0x59b33d17,\r\n\t\t\t0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6," +
                    "\r\n\t\t\t0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\r\n\t\t\t0x73dc1683," +
                    " 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\r\n\t\t\t0xe40ecf0b, 0x9309ff9d, 0x0" +
                    "a00ae27, 0x7d079eb1, 0xf00f9344,\r\n\t\t\t0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf7625" +
                    "75d, 0x806567cb,\r\n\t\t\t0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a," +
                    "\r\n\t\t\t0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\r\n\t\t\t0xd6d6a3e8," +
                    " 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\r\n\t\t\t0xa6bc5767, 0x3fb506dd, 0x4" +
                    "8b2364b, 0xd80d2bda, 0xaf0a1b4c,\r\n\t\t\t0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867d" +
                    "f55, 0x316e8eef,\r\n\t\t\t0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236," +
                    "\r\n\t\t\t0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\r\n\t\t\t0xb2bd0b28," +
                    " 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\r\n\t\t\t0x2cd99e8b, 0x5bdeae1d, 0x9" +
                    "b64c2b0, 0xec63f226, 0x756aa39c,\r\n\t\t\t0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076" +
                    "785, 0x05005713,\r\n\t\t\t0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b," +
                    "\r\n\t\t\t0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\r\n\t\t\t0x68ddb3f8," +
                    " 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\r\n\t\t\t0x18b74777, 0x88085ae6, 0xf" +
                    "f0f6a70, 0x66063bca, 0x11010b5c,\r\n\t\t\t0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166cc" +
                    "f45, 0xa00ae278,\r\n\t\t\t0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7," +
                    "\r\n\t\t\t0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\r\n\t\t\t0x37d83bf0," +
                    " 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\r\n\t\t\t0xbdbdf21c, 0xcabac28a, 0x5" +
                    "3b39330, 0x24b4a3a6, 0xbad03605,\r\n\t\t\t0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667" +
                    "a2e, 0xc4614ab8,\r\n\t\t\t0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b," +
                    "\r\n\t\t\t0x2d02ef8d\r\n\t\t};\r\n\r\n\t\tpublic UInt32 crc32(UInt32 OldCRC,byte NewData) \r\n\t\t{" +
                    "\r\n\t\t\treturn crc_32_tab[(OldCRC & 0xff) ^ NewData] ^ (OldCRC >> 8);\r\n\t\t}\r\n\r\n\r\n\t\t/" +
                    "// <summary>\r\n\t\t/// LZF Compressor\r\n\t\t/// </summary>\r\n\r\n\t\tUInt32 HLOG=14;\r\n\t\tUIn" +
                    "t32 HSIZE=(1<<14);\r\n\r\n\t\t/*\r\n\t\t* don\'t play with this unless you benchmark!\r\n\t\t* " +
                    "decompression is not dependent on the hash function\r\n\t\t* the hashing function mi" +
                    "ght seem strange, just believe me\r\n\t\t* it works ;)\r\n\t\t*/\r\n\t\tUInt32 MAX_LIT=(1 <<" +
                    "  5);\r\n\t\tUInt32 MAX_OFF=(1 << 13);\r\n\t\tUInt32 MAX_REF=((1 <<  8) + (1 << 3));\r\n\r\n" +
                    "\t\tUInt32 FRST(byte[] Array,UInt32 ptr) \r\n\t\t{\r\n\t\t\treturn (UInt32)(((Array[ptr]) <" +
                    "< 8) | Array[ptr+1]);\r\n\t\t}\r\n\r\n\t\tUInt32 NEXT(UInt32 v,byte[] Array,UInt32 ptr)\r\n\t" +
                    "\t{\r\n\t\t\treturn ((v) << 8) | Array[ptr+2];\r\n\t\t}\r\n\r\n\t\tUInt32 IDX(UInt32 h) \r\n\t\t{\r\n\t" +
                    "\t\treturn ((h ^ (h << 5)) >> (int)(((3*8 - HLOG)) - h*5) & (HSIZE - 1));\r\n\t\t}\r\n\r\n" +
                    "\t\t/*\r\n\t\t* compressed format\r\n\t\t*\r\n\t\t* 000LLLLL <L+1>    ; literal\r\n\t\t* LLLOOOOO " +
                    "oooooooo ; backref L\r\n\t\t* 111OOOOO LLLLLLLL oooooooo ; backref L+7\r\n\t\t*\r\n\t\t*/\r\n\r" +
                    "\n\t\tpublic int lzf_compress (byte[] in_data, int in_len,byte[] out_data, int out_" +
                    "len)\r\n\t\t{\r\n\t\t\tint c;\r\n\t\t\tlong []htab=new long[1<<14];\r\n\t\t\tfor (c=0;c<1<<14;c++)\r" +
                    "\n\t\t\t{\r\n\t\t\t\thtab[c]=0;\r\n\t\t\t}\r\n\r\n\t\t\tlong hslot;\r\n\t\t\tUInt32 iidx = 0;\r\n\t\t\tUInt32 oi" +
                    "dx = 0;\r\n\t\t\t//byte *in_end  = ip + in_len;\r\n\t\t\t//byte *out_end = op + out_len;\r\n" +
                    "\t\t\tlong reference;\r\n\r\n\t\t\tUInt32 hval = FRST (in_data,iidx);\r\n\t\t\tlong off;\r\n\t\t\tin" +
                    "t lit = 0;\r\n\r\n\t\t\tfor (;;)\r\n\t\t\t\t{\r\n\t\t\t\tif (iidx < in_len - 2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\thval " +
                    "= NEXT (hval, in_data,iidx);\r\n\t\t\t\t\thslot = IDX (hval);\r\n\t\t\t\t\treference = htab[hs" +
                    "lot]; \r\n\t\t\t\t\thtab[hslot] = (long)iidx;\r\n\r\n\t\t\t\t\tif ((off = iidx - reference - 1) " +
                    "< MAX_OFF \r\n\t\t\t\t\t\t&& iidx + 4 < in_len \r\n\t\t\t\t\t\t&& reference > 0\r\n\t\t\t\t\t\t&& in_dat" +
                    "a[reference+0] == in_data[iidx+0]\r\n\t\t\t\t\t\t&& in_data[reference+1] == in_data[iidx" +
                    "+1]\r\n\t\t\t\t\t\t&& in_data[reference+2] == in_data[iidx+2]\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t/" +
                    "* match found at *reference++ */\r\n\t\t\t\t\t\tUInt32 len = 2;\r\n\t\t\t\t\t\tUInt32 maxlen = (" +
                    "UInt32)in_len - iidx - len;\r\n\t\t\t\t\t\tmaxlen = maxlen > MAX_REF ? MAX_REF : maxlen;" +
                    "\r\n\r\n\t\t\t\t\t\tif (oidx + lit + 1 + 3 >= out_len)\r\n\t\t\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t" +
                    "\t\t\tlen++;\r\n\t\t\t\t\t\twhile (len < maxlen && in_data[reference+len] == in_data[iidx+l" +
                    "en]);\r\n\r\n\t\t\t\t\t\tif (lit!=0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tout_data[oidx++] = (byte)(lit - 1);" +
                    "\r\n\t\t\t\t\t\t\tlit = -lit;\r\n\t\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t\t\tout_data[oidx++] = in_data[iidx+lit];\r\n" +
                    "\t\t\t\t\t\t\twhile ((++lit)!=0);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlen -= 2;\r\n\t\t\t\t\t\tiidx++;\r\n\r\n\t\t\t\t\t\t" +
                    "if (len < 7)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tout_data[oidx++] = (byte)((off >> 8) + (len << 5)" +
                    ");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tout_data[oidx++] = (byte)((off >> 8) " +
                    "+ (  7 << 5));\r\n\t\t\t\t\t\t\tout_data[oidx++] = (byte)(len - 7);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tou" +
                    "t_data[oidx++] = (byte)off;\r\n\r\n\t\t\t\t\t\tiidx += len-1;\r\n\t\t\t\t\t\thval = FRST (in_data," +
                    "iidx);\r\n\r\n\t\t\t\t\t\thval = NEXT (hval,in_data, iidx);\r\n\t\t\t\t\t\thtab[IDX (hval)] = iidx" +
                    ";\r\n\t\t\t\t\t\tiidx++;\r\n\r\n\t\t\t\t\t\thval = NEXT (hval, in_data,iidx);\r\n\t\t\t\t\t\thtab[IDX (hva" +
                    "l)] = iidx;\r\n\t\t\t\t\t\tiidx++;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (iidx " +
                    "== in_len)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t/* one more literal byte we must copy */\r\n\t\t\t\tlit" +
                    "++;\r\n\t\t\t\tiidx++;\r\n\r\n\t\t\t\tif (lit == MAX_LIT)\r\n\t\t\t\t\t{\r\n\t\t\t\t\tif (oidx + 1 + MAX_LIT" +
                    " >= out_len)\r\n\t\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\t\tout_data[oidx++] = (byte)(MAX_LIT - 1);\r\n\t" +
                    "\t\t\t\tlit = -lit;\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t\tout_data[oidx++] = in_data[iidx+lit];\r\n\t\t\t\t\twhil" +
                    "e ((++lit)!=0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\tif (lit!=0)\r\n\t\t\t\t{\r\n\t\t\t\tif (oidx + lit + 1 " +
                    ">= out_len)\r\n\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\tout_data[oidx++] = (byte)(lit - 1);\r\n\t\t\t\tlit " +
                    "= -lit;\r\n\t\t\t\tdo\r\n\t\t\t\t\tout_data[oidx++] = in_data[iidx+lit];\r\n\t\t\t\twhile ((++lit)!" +
                    "=0);\r\n\t\t\t\t}\r\n\r\n\t\t\treturn (int)oidx;\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// LZF Decompres" +
                    "sor\r\n\t\t/// </summary>\r\n\t\tpublic int lzf_decompress ( byte[] in_data, int in_len," +
                    " byte[] out_data, int out_len)\r\n\t\t{\r\n\t\t\tUInt32 iidx=0;\r\n\t\t\tUInt32 oidx=0;\r\n\r\n\t\t\t" +
                    "do\r\n\t\t\t\t{\r\n\t\t\t\tUInt32 ctrl = in_data[iidx++];\r\n\r\n\t\t\t\tif (ctrl < (1 << 5)) /* lit" +
                    "eral run */\r\n\t\t\t\t\t{\r\n\t\t\t\t\tctrl++;\r\n\r\n\t\t\t\t\tif (oidx + ctrl > out_len)\r\n\t\t\t\t\t\t{\r\n\t" +
                    "\t\t\t\t\t//SET_ERRNO (E2BIG);\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t\tout_data[o" +
                    "idx++] = in_data[iidx++];\r\n\t\t\t\t\twhile ((--ctrl)!=0);\r\n\t\t\t\t\t}\r\n\t\t\t\telse /* back r" +
                    "eference */\r\n\t\t\t\t\t{\r\n\t\t\t\t\tUInt32 len = ctrl >> 5;\r\n\r\n\t\t\t\t\tint reference = (int)(" +
                    "oidx - ((ctrl & 0x1f) << 8) - 1);\r\n\r\n\t\t\t\t\tif (len == 7)\r\n\t\t\t\t\t\tlen += in_data[ii" +
                    "dx++];\r\n\t\t\t          \r\n\t\t\t\t\treference -= in_data[iidx++];\r\n\r\n\t\t\t\t\tif (oidx + len" +
                    " + 2 > out_len)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t//SET_ERRNO (E2BIG);\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t\t\t}\r\n" +
                    "\r\n\t\t\t\t\tif (reference < 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t//SET_ERRNO (EINVAL);\r\n\t\t\t\t\t\treturn 0;" +
                    "\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\tout_data[oidx++]=out_data[reference++];\r\n\t\t\t\t\tout_data[oidx++]" +
                    "=out_data[reference++];\r\n\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t\tout_data[oidx++]=out_data[reference++]" +
                    ";\r\n\t\t\t\t\twhile ((--len)!=0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\twhile (iidx < in_len);\r\n\r\n\t\t\tretu" +
                    "rn (int)oidx;\r\n\t\t}\r\n\r\n\t\tpublic CLZF()\r\n\t\t{\r\n\t\t\t//\r\n\t\t\t// TODO: Add ructor logic " +
                    "here\r\n\t\t\t//\r\n\t\t}\r\n\t}\r\n}\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public class CLZFTemplateBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
